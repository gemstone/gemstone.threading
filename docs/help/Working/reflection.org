<?xml version="1.0" encoding="utf-8"?>
<reflection>
  <assemblies>
    <assembly name="Gemstone.Threading">
      <assemblydata version="1.0.7.0" culture="" key="" hash="SHA1" />
      <attributes>
        <attribute>
          <type api="T:System.Reflection.AssemblyCompanyAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Grid Protection Alliance</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyConfigurationAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Release</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyCopyrightAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Copyright © 2020</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDescriptionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>GPA Gemstone Threading Library</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyFileVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>1.0.7.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyInformationalVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>1.0.7 -- Release Build</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyProductAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Gemstone</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyTitleAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Gemstone.Threading</value>
          </argument>
        </attribute>
      </attributes>
    </assembly>
  </assemblies>
  <apis>
    <api id="N:Gemstone.Threading">
      <apidata name="Gemstone.Threading" group="namespace" />
      <elements>
        <element api="T:Gemstone.Threading.ConcurrencyLimiter" />
        <element api="T:Gemstone.Threading.InterprocessLock" />
        <element api="T:Gemstone.Threading.InterprocessReaderWriterLock" />
      </elements>
    </api>
    <api id="T:Gemstone.Threading.ConcurrencyLimiter">
      <apidata name="ConcurrencyLimiter" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.#ctor" />
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)" />
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(System.Int32)" />
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)" />
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.SetMaximumConcurrencyLevel(System.Int32)" />
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.QueueTask(System.Threading.Tasks.Task)" />
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
        <element api="M:Gemstone.Threading.ConcurrencyLimiter.GetScheduledTasks" />
        <element api="P:Gemstone.Threading.ConcurrencyLimiter.CurrentConcurrencyLevel" />
        <element api="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <apidata name="TryDequeue" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="task">
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Threading.Tasks" />
            <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
          </containers>
        </element>
        <element api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <apidata name="TryExecuteTask" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="task">
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Threading.Tasks" />
            <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
          </containers>
        </element>
        <element api="P:System.Threading.Tasks.TaskScheduler.Id">
          <apidata name="Id" group="member" subgroup="property" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <propertydata get="true" />
          <getter name="get_Id" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Threading.Tasks" />
            <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <parameters>
        <parameter name="synchronizedOperationFactory">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <parameters>
        <parameter name="synchronizedOperationFactory">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" ref="true" />
        </parameter>
        <parameter name="maximumConcurrencyLevel">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <parameters>
        <parameter name="maximumConcurrencyLevel">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.ConcurrencyLimiter.CurrentConcurrencyLevel">
      <apidata name="CurrentConcurrencyLevel" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_CurrentConcurrencyLevel" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.GetScheduledTasks">
      <apidata name="GetScheduledTasks" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <returns>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel">
      <apidata name="MaximumConcurrencyLevel" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <propertydata get="true" />
      <getter name="get_MaximumConcurrencyLevel" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.QueueTask(System.Threading.Tasks.Task)">
      <apidata name="QueueTask" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.SetMaximumConcurrencyLevel(System.Int32)">
      <apidata name="SetMaximumConcurrencyLevel" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="maximumConcurrencyLevel">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.ConcurrencyLimiter.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <apidata name="TryExecuteTaskInline" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/ConcurrencyLimiter.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
        <parameter name="taskWasPreviouslyQueued">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.ConcurrencyLimiter" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.InterprocessLock">
      <apidata name="InterprocessLock" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/InterprocessLock.cs" />
      <typedata visibility="public" abstract="true" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.Boolean)" />
        <element api="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.String,System.Boolean)" />
        <element api="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.Boolean,System.Int32,System.Int32)" />
        <element api="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.String,System.Int32,System.Int32,System.Boolean)" />
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.Boolean)">
      <apidata name="GetNamedMutex" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/InterprocessLock.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="perUser">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Mutex" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.String,System.Boolean)">
      <apidata name="GetNamedMutex" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/InterprocessLock.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="name">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="global" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Mutex" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.Boolean,System.Int32,System.Int32)">
      <apidata name="GetNamedSemaphore" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/InterprocessLock.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="perUser">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
        <parameter name="maximumCount" optional="true">
          <type api="T:System.Int32" ref="false" />
          <argument>
            <type api="T:System.Int32" ref="false" />
            <value>10</value>
          </argument>
        </parameter>
        <parameter name="initialCount" optional="true">
          <type api="T:System.Int32" ref="false" />
          <argument>
            <type api="T:System.Int32" ref="false" />
            <value>-1</value>
          </argument>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Semaphore" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.String,System.Int32,System.Int32,System.Boolean)">
      <apidata name="GetNamedSemaphore" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/InterprocessLock.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="name">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="maximumCount" optional="true">
          <type api="T:System.Int32" ref="false" />
          <argument>
            <type api="T:System.Int32" ref="false" />
            <value>10</value>
          </argument>
        </parameter>
        <parameter name="initialCount" optional="true">
          <type api="T:System.Int32" ref="false" />
          <argument>
            <type api="T:System.Int32" ref="false" />
            <value>-1</value>
          </argument>
        </parameter>
        <parameter name="global" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Semaphore" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessLock" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.InterprocessReaderWriterLock">
      <apidata name="InterprocessReaderWriterLock" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <implements>
        <type api="T:System.IDisposable" ref="true" />
      </implements>
      <elements>
        <element api="F:Gemstone.Threading.InterprocessReaderWriterLock.DefaultMaximumConcurrentLocks" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Boolean)" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Int32,System.Boolean)" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.Finalize" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose(System.Boolean)" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)" />
        <element api="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)" />
        <element api="P:Gemstone.Threading.InterprocessReaderWriterLock.MaximumConcurrentLocks" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Boolean)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <parameters>
        <parameter name="name">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="global" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Int32,System.Boolean)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <parameters>
        <parameter name="name">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="maximumConcurrentLocks">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="global" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>True</value>
          </argument>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="F:Gemstone.Threading.InterprocessReaderWriterLock.DefaultMaximumConcurrentLocks">
      <apidata name="DefaultMaximumConcurrentLocks" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <value>10</value>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.IDisposable.Dispose">
          <type api="T:System.IDisposable" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose(System.Boolean)">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="disposing">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock">
      <apidata name="EnterReadLock" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock">
      <apidata name="EnterWriteLock" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock">
      <apidata name="ExitReadLock" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock">
      <apidata name="ExitWriteLock" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.Finalize">
      <apidata name="Finalize" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Object.Finalize">
          <type api="T:System.Object" ref="true" />
        </member>
      </overrides>
      <implements>
        <member api="M:System.Object.Finalize">
          <type api="T:System.Object" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.InterprocessReaderWriterLock.MaximumConcurrentLocks">
      <apidata name="MaximumConcurrentLocks" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_MaximumConcurrentLocks" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)">
      <apidata name="TryEnterReadLock" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)">
      <apidata name="TryEnterWriteLock" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/InterprocessReaderWriterLock.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading" />
        <type api="T:Gemstone.Threading.InterprocessReaderWriterLock" ref="true" />
      </containers>
    </api>
    <api id="N:Gemstone.Threading.Collections">
      <apidata name="Gemstone.Threading.Collections" group="namespace" />
      <elements>
        <element api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
      </elements>
    </api>
    <api id="T:Gemstone.Threading.Collections.PriorityQueue`1">
      <apidata name="PriorityQueue" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <templates>
        <template name="T" />
      </templates>
      <implements>
        <type api="T:System.Collections.Concurrent.IProducerConsumerCollection`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.IEnumerable" ref="true" />
        <type api="T:System.Collections.ICollection" ref="true" />
        <type api="T:System.Collections.Generic.IReadOnlyCollection`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </specialization>
        </type>
      </implements>
      <elements>
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(System.Int32)" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(Gemstone.Threading.Collections.PriorityQueue{`0})" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.Enqueue(`0,System.Int32)" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(System.Int32,`0@)" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(`0@)" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(System.Int32,`0@)" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(`0@)" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.CopyTo(`0[],System.Int32)" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.GetEnumerator" />
        <element api="M:Gemstone.Threading.Collections.PriorityQueue`1.ToArray" />
        <element api="P:Gemstone.Threading.Collections.PriorityQueue`1.Count" />
        <element api="P:Gemstone.Threading.Collections.PriorityQueue`1.IsEmpty" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(Gemstone.Threading.Collections.PriorityQueue{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <parameters>
        <parameter name="priorityQueue">
          <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <parameters>
        <parameter name="priorityLevels">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.CopyTo(`0[],System.Int32)">
      <apidata name="CopyTo" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="array">
          <arrayOf rank="1">
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </arrayOf>
        </parameter>
        <parameter name="index">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)">
          <type api="T:System.Collections.Concurrent.IProducerConsumerCollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.Collections.PriorityQueue`1.Count">
      <apidata name="Count" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_Count" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <implements>
        <member api="P:System.Collections.ICollection.Count">
          <type api="T:System.Collections.ICollection" ref="true" />
        </member>
        <member api="P:System.Collections.Generic.IReadOnlyCollection`1.Count">
          <type api="T:System.Collections.Generic.IReadOnlyCollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.Enqueue(`0,System.Int32)">
      <apidata name="Enqueue" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
        </parameter>
        <parameter name="priority">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.GetEnumerator">
      <apidata name="GetEnumerator" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="true" final="true" />
      <returns>
        <type api="T:System.Collections.Generic.IEnumerator`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </specialization>
        </type>
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.Collections.PriorityQueue`1.IsEmpty">
      <apidata name="IsEmpty" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_IsEmpty" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.ToArray">
      <apidata name="ToArray" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="true" final="true" />
      <returns>
        <arrayOf rank="1">
          <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
        </arrayOf>
      </returns>
      <implements>
        <member api="M:System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray">
          <type api="T:System.Collections.Concurrent.IProducerConsumerCollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(System.Int32,`0@)">
      <apidata name="TryDequeue" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="priority">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="result" out="true">
          <referenceTo>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </referenceTo>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(`0@)">
      <apidata name="TryDequeue" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="result" out="true">
          <referenceTo>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </referenceTo>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(System.Int32,`0@)">
      <apidata name="TryPeek" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="priority">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="result" out="true">
          <referenceTo>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </referenceTo>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(`0@)">
      <apidata name="TryPeek" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Collections/PriorityQueue.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="result" out="true">
          <referenceTo>
            <template name="T" index="0" api="T:Gemstone.Threading.Collections.PriorityQueue`1" />
          </referenceTo>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Collections" />
        <type api="T:Gemstone.Threading.Collections.PriorityQueue`1" ref="true" />
      </containers>
    </api>
    <api id="N:Gemstone.Threading.Strands">
      <apidata name="Gemstone.Threading.Strands" group="namespace" />
      <elements>
        <element api="T:Gemstone.Threading.Strands.PriorityStrand" />
        <element api="T:Gemstone.Threading.Strands.Strand" />
      </elements>
    </api>
    <api id="T:Gemstone.Threading.Strands.PriorityStrand">
      <apidata name="PriorityStrand" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/Strands/PriorityStrand.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.Threading.Strands.PriorityStrand.#ctor" />
        <element api="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(System.Int32)" />
        <element api="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)" />
        <element api="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)" />
        <element api="M:Gemstone.Threading.Strands.PriorityStrand.GetScheduler(System.Int32)" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.PriorityStrand.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Strands/PriorityStrand.cs" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.PriorityStrand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Strands/PriorityStrand.cs" />
      <parameters>
        <parameter name="synchronizedOperationFactory">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.PriorityStrand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Strands/PriorityStrand.cs" />
      <parameters>
        <parameter name="synchronizedOperationFactory">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" ref="true" />
        </parameter>
        <parameter name="priorityLevels">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.PriorityStrand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Strands/PriorityStrand.cs" />
      <parameters>
        <parameter name="priorityLevels">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.PriorityStrand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.PriorityStrand.GetScheduler(System.Int32)">
      <apidata name="GetScheduler" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Strands/PriorityStrand.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="priority">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.PriorityStrand" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.Strands.Strand">
      <apidata name="Strand" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.Threading.Strands.Strand.#ctor" />
        <element api="M:Gemstone.Threading.Strands.Strand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)" />
        <element api="M:Gemstone.Threading.Strands.Strand.QueueTask(System.Threading.Tasks.Task)" />
        <element api="M:Gemstone.Threading.Strands.Strand.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
        <element api="M:Gemstone.Threading.Strands.Strand.TryDequeue(System.Threading.Tasks.Task)" />
        <element api="M:Gemstone.Threading.Strands.Strand.GetScheduledTasks" />
        <element api="P:Gemstone.Threading.Strands.Strand.MaximumConcurrencyLevel" />
        <element api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)">
          <apidata name="TryExecuteTask" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="task">
              <type api="T:System.Threading.Tasks.Task" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Threading.Tasks" />
            <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
          </containers>
        </element>
        <element api="P:System.Threading.Tasks.TaskScheduler.Id">
          <apidata name="Id" group="member" subgroup="property" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <propertydata get="true" />
          <getter name="get_Id" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.Threading.Tasks" />
            <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.Strand.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.Strand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.Strand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <parameters>
        <parameter name="synchronizedOperationFactory">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.Strand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.Strand.GetScheduledTasks">
      <apidata name="GetScheduledTasks" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <returns>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.Strand" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.Strands.Strand.MaximumConcurrencyLevel">
      <apidata name="MaximumConcurrencyLevel" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <propertydata get="true" />
      <getter name="get_MaximumConcurrencyLevel" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.Strand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.Strand.QueueTask(System.Threading.Tasks.Task)">
      <apidata name="QueueTask" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.Strand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.Strand.TryDequeue(System.Threading.Tasks.Task)">
      <apidata name="TryDequeue" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.Strand" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.Strands.Strand.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <apidata name="TryExecuteTaskInline" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/Strands/Strand.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
          <type api="T:System.Threading.Tasks.TaskScheduler" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="task">
          <type api="T:System.Threading.Tasks.Task" ref="true" />
        </parameter>
        <parameter name="taskWasPreviouslyQueued">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.Strands" />
        <type api="T:Gemstone.Threading.Strands.Strand" ref="true" />
      </containers>
    </api>
    <api id="N:Gemstone.Threading.SynchronizedOperations">
      <apidata name="Gemstone.Threading.SynchronizedOperations" group="namespace" />
      <elements>
        <element api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />
        <element api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" />
        <element api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" />
        <element api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />
        <element api="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />
        <element api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" />
      </elements>
    </api>
    <api id="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation">
      <apidata name="DelayedSynchronizedOperation" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <implements>
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </implements>
      <elements>
        <element api="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Run(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRun(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.ExecuteActionAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Factory(System.Action)" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="exceptionAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </specialization>
          </type>
        </parameter>
        <parameter name="exceptionAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay">
      <apidata name="DefaultDelay" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <value>1000</value>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay">
      <apidata name="Delay" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Delay" />
      <setter name="set_Delay" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.ExecuteActionAsync">
      <apidata name="ExecuteActionAsync" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
        </member>
      </overrides>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Factory(System.Action)">
      <apidata name="Factory" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Run(System.Boolean)">
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="runPendingSynchronously" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.ComponentModel.EditorBrowsableAttribute" ref="true" />
          <argument>
            <type api="T:System.ComponentModel.EditorBrowsableState" ref="false" />
            <enumValue>
              <field name="Never" />
            </enumValue>
          </argument>
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync">
      <apidata name="RunAsync" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.RunAsync">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRun(System.Boolean)">
      <apidata name="TryRun" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="runPendingSynchronously" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.ComponentModel.EditorBrowsableAttribute" ref="true" />
          <argument>
            <type api="T:System.ComponentModel.EditorBrowsableState" ref="false" />
            <enumValue>
              <field name="Never" />
            </enumValue>
          </argument>
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync">
      <apidata name="TryRunAsync" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/DelayedSynchronizedOperation.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRunAsync">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation">
      <apidata name="ISynchronizedOperation" group="type" subgroup="interface" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <typedata visibility="public" abstract="true" serializable="false" />
      <implementors>
        <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </implementors>
      <elements>
        <element api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.Run(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRun(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.RunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRunAsync" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsRunning" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsPending" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.CancellationToken" />
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.CancellationToken">
      <apidata name="CancellationToken" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <proceduredata abstract="true" virtual="true" />
      <propertydata get="true" set="true" />
      <getter name="get_CancellationToken" />
      <setter name="set_CancellationToken" />
      <returns>
        <type api="T:System.Threading.CancellationToken" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsPending">
      <apidata name="IsPending" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <proceduredata abstract="true" virtual="true" />
      <propertydata get="true" />
      <getter name="get_IsPending" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsRunning">
      <apidata name="IsRunning" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <proceduredata abstract="true" virtual="true" />
      <propertydata get="true" />
      <getter name="get_IsRunning" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.Run(System.Boolean)">
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <proceduredata abstract="true" virtual="true" />
      <parameters>
        <parameter name="runPendingSynchronously" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.RunAsync">
      <apidata name="RunAsync" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <proceduredata abstract="true" virtual="true" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRun(System.Boolean)">
      <apidata name="TryRun" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <proceduredata abstract="true" virtual="true" />
      <parameters>
        <parameter name="runPendingSynchronously" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRunAsync">
      <apidata name="TryRunAsync" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ISynchronizedOperation.cs" />
      <proceduredata abstract="true" virtual="true" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation">
      <apidata name="LongSynchronizedOperation" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.ExecuteActionAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.Factory(System.Action)" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.IsBackground" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.Run(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRun(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.RunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="exceptionAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </specialization>
          </type>
        </parameter>
        <parameter name="exceptionAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.ExecuteActionAsync">
      <apidata name="ExecuteActionAsync" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
        </member>
      </overrides>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.Factory(System.Action)">
      <apidata name="Factory" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.IsBackground">
      <apidata name="IsBackground" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/LongSynchronizedOperation.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_IsBackground" />
      <setter name="set_IsBackground" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation">
      <apidata name="ShortSynchronizedOperation" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ShortSynchronizedOperation.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.ExecuteActionAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.Factory(System.Action)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.Run(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRun(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.RunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ShortSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ShortSynchronizedOperation.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="exceptionAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.ExecuteActionAsync">
      <apidata name="ExecuteActionAsync" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ShortSynchronizedOperation.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync">
          <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
        </member>
      </overrides>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.Factory(System.Action)">
      <apidata name="Factory" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/ShortSynchronizedOperation.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase">
      <apidata name="SynchronizedOperationBase" group="type" subgroup="class" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <typedata visibility="public" abstract="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
        <descendents>
          <type api="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" ref="true" />
          <type api="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" ref="true" />
          <type api="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" ref="true" />
        </descendents>
      </family>
      <implements>
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </implements>
      <elements>
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action,System.Action{System.Exception})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.Run(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRun(System.Boolean)" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.RunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRunAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync" />
        <element api="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending" />
        <element api="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="family" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action,System.Action{System.Exception})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="family" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
        <parameter name="exceptionAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="family" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="family" special="true" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </specialization>
          </type>
        </parameter>
        <parameter name="exceptionAction">
          <type api="T:System.Action`1" ref="true">
            <specialization>
              <type api="T:System.Exception" ref="true" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken">
      <apidata name="CancellationToken" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" set="true" />
      <getter name="get_CancellationToken" />
      <setter name="set_CancellationToken" />
      <returns>
        <type api="T:System.Threading.CancellationToken" ref="false" />
      </returns>
      <implements>
        <member api="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.CancellationToken">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction">
      <apidata name="ExecuteAction" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync">
      <apidata name="ExecuteActionAsync" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata abstract="true" virtual="true" />
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending">
      <apidata name="IsPending" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_IsPending" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsPending">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning">
      <apidata name="IsRunning" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_IsRunning" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsRunning">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)">
      <apidata name="ProcessException" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="ex">
          <type api="T:System.Exception" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.Run(System.Boolean)">
      <apidata name="Run" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="runPendingSynchronously" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </parameter>
      </parameters>
      <implements>
        <member api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.Run(System.Boolean)">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.RunAsync">
      <apidata name="RunAsync" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.RunAsync">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRun(System.Boolean)">
      <apidata name="TryRun" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="runPendingSynchronously" optional="true">
          <type api="T:System.Boolean" ref="false" />
          <argument>
            <type api="T:System.Boolean" ref="false" />
            <value>False</value>
          </argument>
        </parameter>
      </parameters>
      <implements>
        <member api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRun(System.Boolean)">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRunAsync">
      <apidata name="TryRunAsync" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.Threading/SynchronizedOperations/SynchronizedOperationBase.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRunAsync">
          <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
        <type api="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory">
      <apidata name="SynchronizedOperationFactory" group="type" subgroup="delegate" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <parameters>
        <parameter name="action">
          <type api="T:System.Action" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.Threading" module="Gemstone.Threading" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.Threading.SynchronizedOperations" />
      </containers>
    </api>
  </apis>
</reflection>