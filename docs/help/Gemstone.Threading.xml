<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Gemstone.Threading</name>
  </assembly>
  <members>
    <member name="T:Gemstone.Threading.AsyncLock">
      <summary>
            Represents a lock that can be awaited to obtain exclusive
            access to resources within a critical region of code.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.AsyncLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.EnterAsync">
      <summary>
            Obtains exclusive access to the lock.
            </summary>
      <returns>
            A task that must be awaited to obtain the token that will
            release the lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The lock could not be taken.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.Int32)">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before failing to take the lock.</param>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The timeout expires before the lock could be taken.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.TimeSpan)">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <param name="timeout">The amount of time to wait before failing to take the lock.</param>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <remarks>
        <para>
            The following illustrates an example of using try-catch to detect a failure to take the lock.
            </para>
        <code>
            AsyncLock asyncLock = new AsyncLock();
            
            try
            {
                using IDisposable token = await asyncLock.TryEnterAsync();
                // Critical region
            }
            catch (TaskCanceledException)
            {
                // Lock failed
            }
            </code>
        <para>
            The following illustrates an example of using <see cref="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
            to detect a failure to take the lock.
            </para>
        <code>
            AsyncLock asyncLock = new AsyncLock();
            
            await asyncLock.TryEnterAsync().ContinueWith(async tokenTask =&gt;
            {
                if (tokenTask.IsCanceled)
                {
                    // Lock failed
                    return;
                }
            
                using IDisposable token = await tokenTask;
                // Critical region
            }).Unwrap();
            </code>
      </remarks>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The <paramref name="timeout" /> expires before the lock could be taken.</exception>
    </member>
    <member name="T:Gemstone.Threading.AsyncReaderWriterLock">
      <summary>
            Represents an asynchronous implementation of a reader/writer lock.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.AsyncReaderWriterLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterReadAsync">
      <summary>
            Enters the lock with concurrent access where all readers
            can execute concurrently with respect to each other.
            </summary>
      <returns>The token used to control the duration of entry.</returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterWriteAsync">
      <summary>
            Enters the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <returns>The token used to control the duration of entry.</returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.Int32)">
      <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.TimeSpan)">
      <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
      <param name="timeout">The amount of time to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout" /> expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.Int32)">
      <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.TimeSpan)">
      <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <param name="timeout">The amount of time to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout" /> expired.</exception>
    </member>
    <member name="T:Gemstone.Threading.ConcurrencyLimiter">
      <summary>
            Task scheduler that limits the number of tasks that can execute in parallel at any given time.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" /> and a maximum concurrency
            level equal to the number of processors on the current machine.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class with a
            maximum concurrency level equal to the number of processors on the current machine.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
      <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel" />.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
      <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel" />.</param>
    </member>
    <member name="P:Gemstone.Threading.ConcurrencyLimiter.CurrentConcurrencyLevel">
      <summary>
            Gets the number of threads that are currently executing tasks concurrently.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.GetScheduledTasks">
      <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" />
            instances currently queued to the scheduler waiting to be executed.
            </summary>
      <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
    </member>
    <member name="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel">
      <summary>
            Gets the maximum number of threads that can be executing tasks concurrently.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.SetMaximumConcurrencyLevel(System.Int32)">
      <summary>
            Sets the maximum number of threads that can be executing tasks concurrently.
            </summary>
      <param name="maximumConcurrencyLevel">The maximum concurrency level.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously
            in this call, and if it can, executes it.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</param>
      <param name="taskWasPreviouslyQueued">
            A <see cref="T:System.Boolean" /> denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
      <returns>A <see cref="T:System.Boolean" /> value indicating whether the task was executed inline.</returns>
    </member>
    <member name="T:Gemstone.Threading.InterprocessLock">
      <summary>
            Defines helper methods related to inter-process locking.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.Boolean)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Mutex" /> associated with the running application, typically used to detect whether an instance
            of the application is already running.
            </summary>
      <param name="perUser">Indicates whether to generate a different name for the <see cref="T:System.Threading.Mutex" /> dependent upon the user running the application.</param>
      <returns>A uniquely named inter-process <see cref="T:System.Threading.Mutex" /> specific to the application; <see cref="T:System.Threading.Mutex" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the assembly's GUID when creating the <see cref="T:System.Threading.Mutex" />, if it is available. If it is not available, it uses a hash
            of the simple name of the assembly. Although the name is hashed to help guarantee uniqueness, it is still entirely possible that another application
            may use that name with the same hashing algorithm to generate its <see cref="T:System.Threading.Mutex" /> name. Therefore, it is best to ensure that the
            <see cref="T:System.Runtime.InteropServices.GuidAttribute" /> is defined in the AssemblyInfo of your application.
            </para>
      </remarks>
      <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.String,System.Boolean)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Mutex" /> associated with the specified <paramref name="name" /> that identifies a source object
            needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="global">Determines if mutex should be marked as global; set value to <c>false</c> for local.</param>
      <returns>A uniquely named inter-process <see cref="T:System.Threading.Mutex" /> specific to <paramref name="name" />; <see cref="T:System.Threading.Mutex" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the <paramref name="name" /> when creating the <see cref="T:System.Threading.Mutex" />, not the actual <paramref name="name" /> - this way
            restrictions on the <paramref name="name" /> length do not need to be a user concern. All processes needing an inter-process <see cref="T:System.Threading.Mutex" /> need
            to use this same function to ensure access to the same <see cref="T:System.Threading.Mutex" />.
            </para>
        <para>
            The <paramref name="name" /> can be a string of any length (must not be empty, null or white space) and is not case-sensitive. All hashes of the
            <paramref name="name" /> used to create the global <see cref="T:System.Threading.Mutex" /> are first converted to lower case.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">Argument <paramref name="name" /> cannot be empty, null or white space.</exception>
      <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.Boolean,System.Int32,System.Int32)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Semaphore" /> associated with the running application, typically used to detect whether some number of
            instances of the application are already running.
            </summary>
      <param name="perUser">Indicates whether to generate a different name for the <see cref="T:System.Threading.Semaphore" /> dependent upon the user running the application.</param>
      <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently, or -1 to default to <paramref name="maximumCount" />.</param>
      <returns>A uniquely named inter-process <see cref="T:System.Threading.Semaphore" /> specific to entry assembly; <see cref="T:System.Threading.Semaphore" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the assembly's GUID when creating the <see cref="T:System.Threading.Semaphore" />, if it is available. If it is not available, it uses a hash
            of the simple name of the assembly. Although the name is hashed to help guarantee uniqueness, it is still entirely possible that another application
            may use that name with the same hashing algorithm to generate its <see cref="T:System.Threading.Semaphore" /> name. Therefore, it is best to ensure that the
            <see cref="T:System.Runtime.InteropServices.GuidAttribute" /> is defined in the AssemblyInfo of your application.
            </para>
      </remarks>
      <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.String,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Semaphore" /> associated with the specified <paramref name="name" /> that identifies a source object
            needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently, or -1 to default to <paramref name="maximumCount" />.</param>
      <param name="global">Determines if semaphore should be marked as global; set value to <c>false</c> for local.</param>
      <returns>A uniquely named inter-process <see cref="T:System.Threading.Semaphore" /> specific to <paramref name="name" />; <see cref="T:System.Threading.Semaphore" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the <paramref name="name" /> when creating the <see cref="T:System.Threading.Semaphore" />, not the actual <paramref name="name" /> - this way
            restrictions on the <paramref name="name" /> length do not need to be a user concern. All processes needing an inter-process <see cref="T:System.Threading.Semaphore" /> need
            to use this same function to ensure access to the same <see cref="T:System.Threading.Semaphore" />.
            </para>
        <para>
            The <paramref name="name" /> can be a string of any length (must not be empty, null or white space) and is not case-sensitive. All hashes of the
            <paramref name="name" /> used to create the global <see cref="T:System.Threading.Semaphore" /> are first converted to lower case.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">Argument <paramref name="name" /> cannot be empty, null or white space.</exception>
      <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="T:Gemstone.Threading.InterprocessReaderWriterLock">
      <summary>
            Represents an inter-process reader/writer lock using <see cref="T:System.Threading.Semaphore" /> and <see cref="T:System.Threading.Mutex" /> native locking mechanisms.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Boolean)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> associated with the specified
            <paramref name="name" /> that identifies a source object needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="global">Determines if semaphore and mutex used by <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> should be marked as global; set value to <c>false</c> for local.</param>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Int32,System.Boolean)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> associated with the specified
            <paramref name="name" /> that identifies a source object needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="maximumConcurrentLocks">Maximum concurrent reader locks to allow.</param>
      <param name="global">Determines if semaphore and mutex used by <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> should be marked as global; set value to <c>false</c> for local.</param>
      <remarks>
            If more reader locks are requested than the <paramref name="maximumConcurrentLocks" />, excess reader locks will simply
            wait until a lock is available (i.e., one of the existing reads completes).
            </remarks>
    </member>
    <member name="F:Gemstone.Threading.InterprocessReaderWriterLock.DefaultMaximumConcurrentLocks">
      <summary>
            Default maximum concurrent locks allowed for <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose">
      <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> object.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> object and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock">
      <summary>
            Tries to enter the lock in read mode.
            </summary>
      <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock">
      <summary>
            Tries to enter the lock in write mode.
            </summary>
      <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock">
      <summary>
            Exits read mode and returns the prior read lock count.
            </summary>
      <returns>
        <markup>
          <include item="SMCMissingTag">
            <parameter>returns</parameter>
            <parameter>M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock</parameter>
          </include>
        </markup>
      </returns>
      <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock">
      <summary>
            Exits write mode.
            </summary>
      <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Finalize">
      <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> object is reclaimed by <see cref="T:System.GC" />.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.InterprocessReaderWriterLock.MaximumConcurrentLocks">
      <summary>
            Gets the maximum concurrent reader locks allowed.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)">
      <summary>
            Tries to enter the lock in read mode, with an optional time-out.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</param>
      <returns>
        <c>true</c> if the calling thread entered read mode, otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)" />.
            </para>
        <para>
            Note that this function may wait as long as 2 * <paramref name="millisecondsTimeout" /> since the function first waits for synchronous access
            to the semaphore, then waits again on an available semaphore slot.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)">
      <summary>
            Tries to enter the lock in write mode, with an optional time-out.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</param>
      <returns>
        <c>true</c> if the calling thread entered write mode, otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)" />.
            </para>
        <para>
            Note that this function may wait as long as 2 * <paramref name="millisecondsTimeout" /> since the function first waits for synchronous access
            to the semaphore, then waits again on an available semaphore slot.
            </para>
      </remarks>
    </member>
    <member name="T:Gemstone.Threading.SharedTimer">
      <summary>
            Represents a timer class that will group registered timer event callbacks that operate on the same
            interval in order to optimize thread pool queuing.
            </summary>
      <remarks>
        <para>
            Externally the <see cref="T:Gemstone.Threading.SharedTimer" /> operations similar to the <see cref="T:System.Timers.Timer" />.
            Internally the timer pools callbacks with the same <see cref="P:Gemstone.Threading.SharedTimer.Interval" /> into a single timer where
            each callback is executed on the same thread, per instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler" />. 
            </para>
        <para>
            Any long running callbacks that have a risk of long delays should not use <see cref="T:Gemstone.Threading.SharedTimer" />
            as this will effect the reliability of all of the other <see cref="T:Gemstone.Threading.SharedTimer" /> instances for a
            given <see cref="T:Gemstone.Threading.SharedTimerScheduler" />.
            </para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.AutoReset">
      <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only
            once <c>false</c> or repeatedly <c>true</c>.
            </summary>
      <returns>
        <c>true</c> the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event each time the interval elapses; otherwise,
            <c>false</c> if it should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only once, after the first time the interval elapses.
            The default is <c>true</c>.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Close">
      <summary>
            Stops the timer.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Dispose">
      <summary>
            Stops the timer and prevents reuse of the class.
            </summary>
    </member>
    <member name="E:Gemstone.Threading.SharedTimer.Elapsed">
      <summary>
            Occurs when the timer interval elapses.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Enabled">
      <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
      <returns>
        <c>true</c> if the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event; otherwise, <c>false</c>.
            The default is <c>false</c>.
            </returns>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Interval">
      <summary>
            Gets or sets the interval at which to raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
      <returns>The time, in milliseconds, between <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> events.</returns>
      <remarks>
            The value must be greater than zero, and less than or equal to <see cref="F:System.Int32.MaxValue" />.
            The default is 100 milliseconds.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Start">
      <summary>
            Starts raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>true</c>.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Status">
      <summary>
            Gets the current status details about object providing status information.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Stop">
      <summary>
            Stops raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>false</c>.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SharedTimerScheduler">
      <summary>
            Represents a timer manager which is the scheduler of <see cref="T:Gemstone.Threading.SharedTimer" />.
            </summary>
      <remarks>
            A <see cref="T:Gemstone.Threading.SharedTimer" /> with the same scheduler will use the same ThreadPool thread to process
            all of the <see cref="T:Gemstone.Threading.SharedTimer" /> instances in series when they have a common interval. Call
            order, based on registration sequence, will be preserved.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.CreateTimer(System.Int32)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.SharedTimer" /> using the current <see cref="T:Gemstone.Threading.SharedTimerScheduler" />.
            </summary>
      <param name="interval">The interval of the timer, default is 100.</param>
      <returns>A shared timer instance that fires at the given interval.</returns>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimerScheduler.IsDisposed">
      <summary>
            Gets flag that determines if this <see cref="T:Gemstone.Threading.SharedTimerScheduler" /> instance has been disposed.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.TaskCompletionSourceFactory">
      <summary>
            Provides factory functions for creating new
            <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> objects.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1">
      <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> class.
            </summary>
      <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
      <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1(System.Object)">
      <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> class.
            </summary>
      <param name="state">The state to use as the underlying <see cref="T:System.Threading.Tasks.Task" />'s <see cref="P:System.Threading.Tasks.Task.AsyncState" />.</param>
      <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
      <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</returns>
    </member>
    <member name="F:Gemstone.Threading.TaskCompletionSourceFactory.DefaultTaskCreationOptions">
      <summary>
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used by this factory
            for creating new <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> objects.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.WeakAction">
      <summary>
            Provides a weak referenced <see cref="T:System.Action" /> delegate.
            </summary>
      <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.#ctor(System.Action)">
      <summary>
            Creates a WeakAction.
            </summary>
      <param name="callback">The callback.</param>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.Clear">
      <summary>
            Clears <see cref="T:System.Action" /> callback target.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.TryInvoke">
      <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.WeakAction`1">
      <summary>
            Provides a weak referenced <see cref="T:System.Action" /> delegate.
            </summary>
      <typeparam name="T">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>typeparam</parameter>
            <parameter>T</parameter>
            <parameter>T:Gemstone.Threading.WeakAction`1</parameter>
          </include>
        </markup>
      </typeparam>
      <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.#ctor(System.Action{`0})">
      <summary>
            Creates a WeakAction.
            </summary>
      <param name="callback">The callback.</param>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.Clear">
      <summary>
            Clears <see cref="T:System.Action" /> callback target.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.TryInvoke(`0)">
      <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
      <param name="param1">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>param</parameter>
            <parameter>param1</parameter>
            <parameter>M:Gemstone.Threading.WeakAction`1.TryInvoke(`0)</parameter>
          </include>
        </markup>
      </param>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1">
      <summary>
            Combines <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" /> and <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> to provide
            a low-contention, double-buffered queue suitable for multiple-producer, single-consumer
            scenarios.
            </summary>
      <typeparam name="T">Type of items being queued.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1" /> class.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Count">
      <summary>
            Gets the number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Enqueues a collection of items into the async double-buffered queue.
            </summary>
      <param name="items">The items to be queued.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessItemsFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.AsyncQueue`1">
      <summary>
            Creates a fast, light-weight asynchronous processing queue with very low contention.
            </summary>
      <typeparam name="T">Type of items to process.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor">
      <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType)">
      <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <param name="synchronizedOperationType">The type of synchronized operation to use to process items in the queue.</param>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Count">
      <summary>
            Gets the total number of items currently in the queue.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Enabled">
      <summary>
            Gets or sets flag that enables or disables processing.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.Enqueue(`0)">
      <summary>
            Enqueues an item for processing.
            </summary>
      <param name="item">Item to be queued for processing.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.AsyncQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.ProcessItemFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1">
      <summary>
            A thread-safe double-buffered queue that allows for low-contention
            item processing in single-producer, single-consumer scenarios.
            </summary>
      <typeparam name="T">Type of items being queued.</typeparam>
      <remarks>
            It is not safe to use this class with multiple consumer threads.
            The <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue" /> method must be called by one thread at
            a time, and the consumer must not access a list returned by Dequeue
            after its next call to Dequeue.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Clear">
      <summary>
            Empties the producer's buffer so that the
            items can no longer be consumed by the consumer.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Count">
      <summary>
            Gets the current number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue">
      <summary>
            Dequeues a collection of items from the queue.
            </summary>
      <returns>
            A collection of items that have previously been enqueued,
            or no items if none have been enqueued since last dequeue.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Enqueues a collection of items into the double-buffered queue.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessItemsFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryClear">
      <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
      <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryDequeue(System.Collections.Generic.IList{`0}@)">
      <summary>
            Attempts to dequeue a collection of items from the queue and
            returns the number of items left in the queue after dequeuing.
            </summary>
      <param name="items">The items that were dequeued.</param>
      <returns>
            The number of items left in the queue after
            dequeuing as many items as possible.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryEnqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
      <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1">
      <summary>
            Manages queues to reduce contention for a multi-threaded, multiple-producer, single-consumer scenario.
            </summary>
      <typeparam name="T">The types of items to be queued.</typeparam>
      <remarks>
            For best results, each thread that is producing items to the consumer should call
            <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer" /> to receive a producer object that will not contend with
            any other producer. The consumer should either provide a handler to process the queued
            items or poll the manager by calling <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue" /> (not both!). It is not
            safe to use this class with multiple consumer threads.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
      <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
      <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue">
      <summary>
            Dequeues a list of items produced by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" />s.
            </summary>
      <returns>A list of items to be consumed.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer">
      <summary>
            Creates a producer used to produce items to the consumer of this <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" />.
            </summary>
      <returns>A <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> used to produce items to the consumer.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.ItemsLeft">
      <summary>
            Gets a flag that indicates whether there are any items left to
            be consumed after the last call to <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue" />.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1">
      <summary>
            A producer for a <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> which can
            only be used to provide items to the queue for consumption.
            </summary>
      <typeparam name="T">The type of the items produced to the queue.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose">
      <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Finalize">
      <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object is reclaimed by <see cref="T:System.GC" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Produce(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Produces a collection of items to be processed by the consumer.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
    </member>
    <member name="T:Gemstone.Threading.Collections.PriorityQueue`1">
      <summary>
            Represents a thread-safe prioritized first in-first out (FIFO) collection.
            </summary>
      <typeparam name="T">The type of elements contained in the queue.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(Gemstone.Threading.Collections.PriorityQueue{`0})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
      <param name="priorityQueue">Another priority queue of items to be enqueued in this queue at the same priority.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priorityQueue" /> queue length is less than or equal to 0.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="priorityQueue" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
      <param name="priorityLevels">The number of priority levels to preallocate in the queue.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priorityLevels" /> is less than or equal to 0.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> elements to an existing
            one-dimensional <see cref="T:System.Array" />, starting at the specified array index.
            </summary>
      <param name="array">
            The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
            from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />. The <see cref="T:System.Array" /> must
            have zero-based indexing.
            </param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
            index is equal to or greater than the length of the array -or- The number of
            elements in the source <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> is greater
            than the available space from index to the end of the destination array.
            </exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.Count">
      <summary>
            Gets the number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.Enqueue(`0,System.Int32)">
      <summary>
            Enqueues an item into the priority queue.
            </summary>
      <param name="item">The item to be enqueued.</param>
      <param name="priority">The priority at which the item should be queued. Larger numbers have higher priority!</param>
      <remarks>
            This priority queue is implemented using an array of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.
            The array index indicates the priority of tasks in each queue. For best performance,
            ensure that your code defines all priority levels consecutively, starting from 0.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is negative</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.
            </summary>
      <returns>An enumerator for the contents of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.IsEmpty">
      <summary>
            Indicates whether the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> is empty.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.ToArray">
      <summary>
            Copies the elements stored in the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> to a new array.
            </summary>
      <returns>A new array containing a snapshot of elements copied from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(System.Int32,`0@)">
      <summary>
            Dequeues an item from the priority queue.
            </summary>
      <param name="priority">The priority at which the item should be dequeued.</param>
      <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
      <returns>True if an item was dequeued; false if the queue is empty.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(`0@)">
      <summary>
            Dequeues an item from the priority queue.
            </summary>
      <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
      <returns>True if an item was dequeued; false if the queue is empty.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(System.Int32,`0@)">
      <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> without removing it.
            </summary>
      <param name="priority">The priority at which to peek into the queue.</param>
      <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> or an unspecified value if the operation failed.
            </param>
      <returns>true if an object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(`0@)">
      <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> without removing it.
            </summary>
      <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> or an unspecified value if the operation failed.
            </param>
      <returns>true if an object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="T:Gemstone.Threading.Strands.PriorityStrand">
      <summary>
            Schedules tasks in a collection of FIFO queues and executes them in priority order.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
      <param name="priorityLevels">The number of priority levels to be preallocated by the priority queue.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
      <param name="priorityLevels">The number of priority levels to be preallocated by the priority queue.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.GetScheduler(System.Int32)">
      <summary>
            Gets a <see cref="T:System.Threading.Tasks.TaskScheduler" /> used to queue tasks at a specific priority.
            </summary>
      <param name="priority">The priority at which tasks should be queued by the returned <see cref="T:System.Threading.Tasks.TaskScheduler" />. Higher numbers are higher in priority!</param>
      <returns>A <see cref="T:System.Threading.Tasks.TaskScheduler" /> that queues tasks into the strand at the given priority.</returns>
      <remarks>For a strand with <c>n</c> priorities, it is recommended to use priority levels between <c>0</c> and <c>n-1</c> inclusive.</remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is less than zero</exception>
    </member>
    <member name="T:Gemstone.Threading.Strands.Strand">
      <summary>
            Schedules tasks in a FIFO queue and executes them in a synchronized asynchronous loop.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.GetScheduledTasks">
      <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" />
            instances currently queued to the scheduler waiting to be executed.
            </summary>
      <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
    </member>
    <member name="P:Gemstone.Threading.Strands.Strand.MaximumConcurrencyLevel">
      <summary>
            Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.TryDequeue(System.Threading.Tasks.Task)">
      <summary>
            Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</param>
      <returns>A Boolean denoting whether the task argument was successfully dequeued.</returns>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Attempts to executes a task inline, but only if this method is
            called on the processing thread to avoid parallel execution of tasks.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</param>
      <param name="taskWasPreviouslyQueued">
            A Boolean denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
      <returns>A Boolean value indicating whether the task was executed inline.</returns>
      <remarks>
            Inline execution allows tasks to skip the line and run out of order.
            The only reason inline execution is supported at all is to avoid a common
            case of deadlocking where a task is queued in advance of another task that it
            depends on (via <see cref="M:System.Threading.Tasks.Task.Wait" />, for instance). However, deadlocks can
            still occur when waiting on tasks scheduled by a different strand. To avoid
            out-of-order execution and deadlocks, be very careful about using API calls
            that wait on tasks.
            </remarks>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation">
      <summary>
            Represents a short-running synchronized operation that cannot run while it is already
            in progress. Async operations will execute on the thread-pool after the specified
            <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds.
            </summary>
      <remarks>
            By default, the action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />
            is executed on the <see cref="T:System.Threading.ThreadPool" /> when running the operation asynchronously.
            When the operation is set to pending, the action is executed in an asynchronous loop on
            the thread pool until all pending operations have been completed. Since the action is
            executed on the thread pool, it is best if it can be executed quickly, without
            blocking the thread or putting it to sleep. If completion of the operation is
            critical, such as when saving data to a file, this type of operation should not
            be used since thread pool threads are background threads and will not prevent the
            program from ending before the operation is complete.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay">
      <summary>
            Defines the default value for the <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> property.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay">
      <summary>
            Gets or sets the amount of time to wait before execution, in milliseconds,
            for any asynchronous calls. Zero value will execute immediately.
            </summary>
      <remarks>
            Non asynchronous calls will not be delayed.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.ExecuteActionAsync">
      <summary>
            Executes the action on a separate thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Factory(System.Action)">
      <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" /> signature.
            </summary>
      <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.</param>
      <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> with <see cref="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay" /> of 1000 milliseconds.</returns>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Run(System.Boolean)">
      <summary>
            Executes the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds or marks
            the operation as pending if the operation is already running. Method same as <see cref="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync" /> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </summary>
      <param name="runPendingSynchronously">
            Defines synchronization mode for running any pending operation; must be <c>false</c> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </param>
      <remarks>
        <para>
            For <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />, actions will always run on another thread so this method is
            hidden from intellisense.
            </para>
        <para>
            When the operation is marked as pending, it will run again after the operation that is currently running
            has completed. This is useful if an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="runPendingSynchronously" /> must be <c>false</c> for <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </exception>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync">
      <summary>
            Executes the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds or marks
            the operation as pending if the operation is already running
            </summary>
      <remarks>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRun(System.Boolean)">
      <summary>
            Attempts to execute the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds.
            Does nothing if the operation is already running. Method same as <see cref="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync" /> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </summary>
      <param name="runPendingSynchronously">
            Defines synchronization mode for running any pending operation; must be <c>false</c> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </param>
      <remarks>
            For <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />, actions will always run on another thread so this method is
            hidden from intellisense.
            </remarks>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="runPendingSynchronously" /> must be <c>false</c> for <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </exception>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds.
            Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation">
      <summary>
            Represents an operation that cannot run while it is already in progress.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.CancellationToken">
      <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken" /> to use for canceling actions.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsPending">
      <summary>
            Gets flag indicating if the synchronized operation has an additional operation that is pending
            execution after the currently running action has completed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsRunning">
      <summary>
            Gets flag indicating if the synchronized operation is currently executing its action.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.Run(System.Boolean)">
      <summary>
            Executes the action on current thread or marks the operation as pending if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
        <para>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </para>
        <para>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.RunAsync">
      <summary>
            Executes the action on another thread or marks the operation as pending if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, it will run again after the operation that is currently running
            has completed. This is useful if an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRun(System.Boolean)">
      <summary>
            Attempts to execute the action on current thread. Does nothing if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread. Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation">
      <summary>
            Represents a long-running synchronized operation that cannot run while it is already in progress.
            </summary>
      <remarks>
        <para>
            The action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> is executed on
            its own dedicated thread when running the operation in the foreground asynchronously.
            When running on its own thread, the action is executed in a tight loop until all
            pending operations have been completed. This type of synchronized operation should
            be preferred if operations may take a long time, block the thread, or put it to sleep.
            It is also recommended to prefer this type of operation if the speed of the operation
            is not critical or if completion of the operation is critical, such as when saving data
            to a file.
            </para>
        <para>
            If the <see cref="P:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.IsBackground" /> property is changed while the synchronized operation
            is running, behavior is undefined.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The cancellable action to be performed if an exception is thrown from the action.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.ExecuteActionAsync">
      <summary>
            Executes the action on a separate thread.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.Factory(System.Action)">
      <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" /> signature.
            </summary>
      <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />.</param>
      <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />.</returns>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.IsBackground">
      <summary>
            Gets or sets whether or not the thread executing the action is a background thread.
            </summary>
      <remarks>
            This defaults to <c>false</c>, be aware that foreground thread will prevent shutdown
            while task is running. If a task keeps getting marked as pending, application will not
            shutdown; consider a cancellable action for <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />
            instances that use a foreground thread.
            </remarks>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation">
      <summary>
            Represents a short-running synchronized operation that cannot run while it is already in progress.
            </summary>
      <remarks>
            By default, the action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />
            is executed on the <see cref="T:System.Threading.ThreadPool" /> when running the operation asynchronously.
            When the operation is set to pending, the action is executed in an asynchronous loop
            on the thread pool until all pending operations have been completed. Since the action
            is executed on the thread pool, it is best if it can be executed quickly, without
            blocking the thread or putting it to sleep. If completion of the operation is
            critical, such as when saving data to a file, this type of operation should not
            be used since thread pool threads are background threads and will not prevent the
            program from ending before the operation is complete.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.ExecuteActionAsync">
      <summary>
            Executes the action in an asynchronous loop on
            the thread pool, as long as the operation is pending.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.Factory(System.Action)">
      <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" /> signature.
            </summary>
      <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.</param>
      <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.</returns>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase">
      <summary>
            Base class for operations that cannot run while they is already in progress.
            </summary>
      <remarks>
        <para>
            This class handles the synchronization between the methods defined in the <see cref="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" />
            interface. Implementers should only need to implement the <see cref="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync" /> method to provide a
            mechanism for executing the action on a separate thread.
            </para>
        <para>
            If subclass implementations get constructed without an exception handler, applications should attach to the static
            <see cref="E:Gemstone.LibraryEvents.SuppressedException" /> event so that any unhandled exceptions can be exposed to a log.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken">
      <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken" /> to use for cancelling actions.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction">
      <summary>
            Executes the action once on the current thread.
            </summary>
      <returns>
        <c>true</c> if the action was pending and needs to run again; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync">
      <summary>
             Executes the action on a separate thread.
             </summary>
      <remarks>
             Implementers should call <see cref="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction" /> on a separate thread and check the return value.
             If it returns true, that means it needs to run again. The following is a sample implementation using
             a regular dedicated thread:
             <code language="cs">
             protected override void ExecuteActionAsync()
             {
                 Thread actionThread = new Thread(() =&gt;
                 {
                     while (ExecuteAction())
                     {
                     }
                 });
            
                 actionThread.Start();
             }
             </code></remarks>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending">
      <summary>
            Gets flag indicating if the synchronized operation has an additional operation that is pending
            execution after the currently running action has completed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning">
      <summary>
            Gets flag indicating if the synchronized operation is currently executing its action.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)">
      <summary>
            Processes an exception thrown by an operation.
            </summary>
      <param name="ex">
        <see cref="T:System.Exception" /> to be processed.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.Run(System.Boolean)">
      <summary>
            Executes the action on current thread or marks the operation as pending if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
        <para>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </para>
        <para>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.RunAsync">
      <summary>
            Executes the action on another thread or marks the operation as pending if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRun(System.Boolean)">
      <summary>
            Attempts to execute the action on current thread. Does nothing if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread. Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory">
      <summary>
            Factory method for creating synchronized operations.
            </summary>
      <param name="action">The action to be synchronized by the operation.</param>
      <returns>The operation that synchronizes the given action.</returns>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType">
      <summary>
            Represents the available types of synchronized operations.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.Short">
      <summary>
        <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />
      </summary>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.Long">
      <summary>
        <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />
      </summary>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.LongBackground">
      <summary>
        <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> with IsBackground set to <c>true</c></summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation">
      <summary>
            Represents a task-based synchronized operation
            that cannot run while it is already in progress.
            </summary>
      <remarks>
        <para>
            The action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> is executed using
            <see cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />. Pending actions run when the task returned by the
            asynchronous action is completed. This synchronized operation only supports the async
            methods on the <see cref="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" /> interface because the async action
            cannot be executed synchronously.
            </para>
        <para>
            The following example shows how to use <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> to
            implement a notifier that receives notification requests ad-hoc but sends notifications
            no more than once every 15 seconds.
            </para>
        <code language="cs">
            public ExampleClass() =&gt;
                SynchronizedOperation = new TaskSynchronizedOperation(NotifyAsync);
                
            public void SendNotification() =&gt;
                SynchronizedOperation.RunOnceAsync();
                
            private async Task NotifyAsync()
            {
                Notify();
                await Task.Delay(15000);
            }
            </code>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.Tasks.Task})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.Tasks.Task},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.CancellationToken">
      <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken" /> to use for canceling actions.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.IsPending">
      <summary>
            Gets a value to indiate whether the synchronized operation
            has an additional operation that is pending execution after
            the currently running action has completed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.IsRunning">
      <summary>
            Gets a value to indicate whether the synchronized
            operation is currently executing its action.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.RunAsync">
      <summary>
            Executes the action on another thread or marks the
            operation as pending if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, it will run again after the
            operation that is currently running has completed. This is useful if
            an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread.
            Does nothing if the operation is already running.
            </summary>
    </member>
  </members>
</doc>