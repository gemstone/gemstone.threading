<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Gemstone.Threading</name>
  </assembly>
  <members>
    <member name="T:Gemstone.Threading.AsyncLock">
      <summary>
            Represents a lock that can be awaited to obtain exclusive
            access to resources within a critical region of code.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.AsyncLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.EnterAsync">
      <summary>
            Obtains exclusive access to the lock.
            </summary>
      <returns>
            A task that must be awaited to obtain the token that will
            release the lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The lock could not be taken.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.Int32)">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before failing to take the lock.</param>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The timeout expires before the lock could be taken.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncLock.TryEnterAsync(System.TimeSpan)">
      <summary>
            Attempts to obtain exclusive access to the lock.
            </summary>
      <param name="timeout">The amount of time to wait before failing to take the lock.</param>
      <returns>
            A task that, if cancelled, indicates the lock was not taken,
            and must be awaited to obtain the token that will release the
            lock on <see cref="M:System.IDisposable.Dispose" />.
            </returns>
      <remarks>
        <para>
            The following illustrates an example of using try-catch to detect a failure to take the lock.
            </para>
        <code>
            AsyncLock asyncLock = new AsyncLock();
            
            try
            {
                using IDisposable token = await asyncLock.TryEnterAsync();
                // Critical region
            }
            catch (TaskCanceledException)
            {
                // Lock failed
            }
            </code>
        <para>
            The following illustrates an example of using <see cref="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
            to detect a failure to take the lock.
            </para>
        <code>
            AsyncLock asyncLock = new AsyncLock();
            
            await asyncLock.TryEnterAsync().ContinueWith(async tokenTask =&gt;
            {
                if (tokenTask.IsCanceled)
                {
                    // Lock failed
                    return;
                }
            
                using IDisposable token = await tokenTask;
                // Critical region
            }).Unwrap();
            </code>
      </remarks>
      <exception cref="T:System.Threading.Tasks.TaskCanceledException">The <paramref name="timeout" /> expires before the lock could be taken.</exception>
    </member>
    <member name="T:Gemstone.Threading.AsyncReaderWriterLock">
      <summary>
            Represents an asynchronous implementation of a reader/writer lock.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.AsyncReaderWriterLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterReadAsync">
      <summary>
            Enters the lock with concurrent access where all readers
            can execute concurrently with respect to each other.
            </summary>
      <returns>The token used to control the duration of entry.</returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.EnterWriteAsync">
      <summary>
            Enters the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <returns>The token used to control the duration of entry.</returns>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.Int32)">
      <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterReadLockAsync(System.TimeSpan)">
      <summary>
            Attempts to enter the lock with concurrent access where all
            readers can execute concurrently with respect to each other.
            </summary>
      <param name="timeout">The amount of time to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout" /> expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.Int32)">
      <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <param name="milliseconds">The number of milliseconds to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the timeout expired.</exception>
    </member>
    <member name="M:Gemstone.Threading.AsyncReaderWriterLock.TryEnterWriteLockAsync(System.TimeSpan)">
      <summary>
            Attempts to enter the lock with exclusive access where no other
            readers or writers can execute concurrently with the writer.
            </summary>
      <param name="timeout">The amount of time to wait before timing out.</param>
      <returns>The token used to control the duration of entry.</returns>
      <exception cref="T:System.TimeoutException">The lock could not be entered before the <paramref name="timeout" /> expired.</exception>
    </member>
    <member name="T:Gemstone.Threading.ConcurrencyLimiter">
      <summary>
            Task scheduler that limits the number of tasks that can execute in parallel at any given time.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" /> and a maximum concurrency
            level equal to the number of processors on the current machine.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class with a
            maximum concurrency level equal to the number of processors on the current machine.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operations to be used for processing tasks.</param>
      <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel" />.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.ConcurrencyLimiter" /> class
            with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
      <param name="maximumConcurrencyLevel">The initial value for <see cref="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel" />.</param>
    </member>
    <member name="P:Gemstone.Threading.ConcurrencyLimiter.CurrentConcurrencyLevel">
      <summary>
            Gets the number of threads that are currently executing tasks concurrently.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.GetScheduledTasks">
      <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" />
            instances currently queued to the scheduler waiting to be executed.
            </summary>
      <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
    </member>
    <member name="P:Gemstone.Threading.ConcurrencyLimiter.MaximumConcurrencyLevel">
      <summary>
            Gets the maximum number of threads that can be executing tasks concurrently.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.SetMaximumConcurrencyLevel(System.Int32)">
      <summary>
            Sets the maximum number of threads that can be executing tasks concurrently.
            </summary>
      <param name="maximumConcurrencyLevel">The maximum concurrency level.</param>
    </member>
    <member name="M:Gemstone.Threading.ConcurrencyLimiter.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously
            in this call, and if it can, executes it.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</param>
      <param name="taskWasPreviouslyQueued">
            A <see cref="T:System.Boolean" /> denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
      <returns>A <see cref="T:System.Boolean" /> value indicating whether the task was executed inline.</returns>
    </member>
    <member name="T:Gemstone.Threading.InterprocessLock">
      <summary>
            Defines helper methods related to inter-process locking.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.InterprocessLock.DefaultMutexGlobal">
      <summary>
            Default value for <see cref="T:System.Threading.Mutex" /> global flag.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.InterprocessLock.DefaultSemaphoreGlobal">
      <summary>
            Default value for <see cref="T:Gemstone.Threading.NamedSemaphore" /> global flag.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.InterprocessLock.DefaultSemaphoreInitialCount">
      <summary>
            Default value for <see cref="T:Gemstone.Threading.NamedSemaphore" /> initial count.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.InterprocessLock.DefaultSemaphoreMaximumCount">
      <summary>
            Default value for <see cref="T:Gemstone.Threading.NamedSemaphore" /> maximum count.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.Boolean)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Mutex" /> associated with the running application, typically used to detect whether an instance
            of the application is already running.
            </summary>
      <param name="perUser">Indicates whether to generate a different name for the <see cref="T:System.Threading.Mutex" /> dependent upon the user running the application.</param>
      <returns>A uniquely named inter-process <see cref="T:System.Threading.Mutex" /> specific to the application; <see cref="T:System.Threading.Mutex" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the assembly's GUID when creating the <see cref="T:System.Threading.Mutex" />, if it is available. If it is not available, it uses a hash
            of the simple name of the assembly. Although the name is hashed to help guarantee uniqueness, it is still entirely possible that another application
            may use that name with the same hashing algorithm to generate its <see cref="T:System.Threading.Mutex" /> name. Therefore, it is best to ensure that the
            <see cref="T:System.Runtime.InteropServices.GuidAttribute" /> is defined in the AssemblyInfo of your application.
            </para>
      </remarks>
      <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedMutex(System.String,System.Boolean)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:System.Threading.Mutex" /> associated with the specified <paramref name="name" /> that identifies a source object
            needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="global">Determines if mutex should be marked as global; set value to <c>false</c> for local.</param>
      <returns>A uniquely named inter-process <see cref="T:System.Threading.Mutex" /> specific to <paramref name="name" />; <see cref="T:System.Threading.Mutex" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the <paramref name="name" /> when creating the <see cref="T:System.Threading.Mutex" />, not the actual <paramref name="name" /> - this way
            restrictions on the <paramref name="name" /> length do not need to be a user concern. All processes needing an inter-process <see cref="T:System.Threading.Mutex" /> need
            to use this same function to ensure access to the same <see cref="T:System.Threading.Mutex" />.
            </para>
        <para>
            The <paramref name="name" /> can be a string of any length (must not be empty, null or white space) and is not case-sensitive. All hashes of the
            <paramref name="name" /> used to create the global <see cref="T:System.Threading.Mutex" /> are first converted to lower case.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">Argument <paramref name="name" /> cannot be empty, null or white space.</exception>
      <exception cref="T:System.UnauthorizedAccessException">The named mutex exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.Boolean,System.Int32,System.Int32)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore" /> associated with the running application, typically used to detect whether some number of
            instances of the application are already running.
            </summary>
      <param name="perUser">Indicates whether to generate a different name for the <see cref="T:Gemstone.Threading.NamedSemaphore" /> dependent upon the user running the application.</param>
      <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently, or -1 to default to <paramref name="maximumCount" />.</param>
      <returns>A uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore" /> specific to entry assembly; <see cref="T:Gemstone.Threading.NamedSemaphore" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the assembly's GUID when creating the <see cref="T:Gemstone.Threading.NamedSemaphore" />, if it is available. If it is not available, it uses a hash
            of the simple name of the assembly. Although the name is hashed to help guarantee uniqueness, it is still entirely possible that another application
            may use that name with the same hashing algorithm to generate its <see cref="T:Gemstone.Threading.NamedSemaphore" /> name. Therefore, it is best to ensure that the
            <see cref="T:System.Runtime.InteropServices.GuidAttribute" /> is defined in the AssemblyInfo of your application.
            </para>
        <para>
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore" /> exhibits kernel persistence, meaning instances will remain active beyond the lifespan of the
            creating process. Named semaphores must be explicitly removed by invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" /> when they are no longer needed.
            Kernel persistence necessitates careful design consideration regarding the responsibility for invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" />.
            Since the common use case for named semaphores is across multiple applications, it is advisable for the last exiting process to handle the
            cleanup. In cases where an application may crash before calling <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" />, the semaphore persists in the system,
            potentially leading to resource leakage. Implementations should include strategies to address and mitigate this risk.
            </para>
      </remarks>
      <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="M:Gemstone.Threading.InterprocessLock.GetNamedSemaphore(System.String,System.Int32,System.Int32,System.Boolean)">
      <summary>
            Gets a uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore" /> associated with the specified <paramref name="name" /> that identifies a source object
            needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently, or -1 to default to <paramref name="maximumCount" />.</param>
      <param name="global">Determines if semaphore should be marked as global; set value to <c>false</c> for local.</param>
      <returns>A uniquely named inter-process <see cref="T:Gemstone.Threading.NamedSemaphore" /> specific to <paramref name="name" />; <see cref="T:Gemstone.Threading.NamedSemaphore" /> is created if it does not exist.</returns>
      <remarks>
        <para>
            This function uses a hash of the <paramref name="name" /> when creating the <see cref="T:Gemstone.Threading.NamedSemaphore" />, not the actual <paramref name="name" /> - this way
            restrictions on the <paramref name="name" /> length do not need to be a user concern. All processes needing an inter-process <see cref="T:Gemstone.Threading.NamedSemaphore" /> need
            to use this same function to ensure access to the same <see cref="T:Gemstone.Threading.NamedSemaphore" />.
            </para>
        <para>
            The <paramref name="name" /> can be a string of any length (must not be empty, null or white space) and is not case-sensitive. All hashes of the
            <paramref name="name" /> used to create the global <see cref="T:Gemstone.Threading.NamedSemaphore" /> are first converted to lower case.
            </para>
        <para>
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore" /> exhibits kernel persistence, meaning instances will remain active beyond the lifespan of the
            creating process. Named semaphores must be explicitly removed by invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" /> when they are no longer needed.
            Kernel persistence necessitates careful design consideration regarding the responsibility for invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" />.
            Since the common use case for named semaphores is across multiple applications, it is advisable for the last exiting process to handle the
            cleanup. In cases where an application may crash before calling <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" />, the semaphore persists in the system,
            potentially leading to resource leakage. Implementations should include strategies to address and mitigate this risk.
            </para>
      </remarks>
      <exception cref="T:System.ArgumentNullException">Argument <paramref name="name" /> cannot be empty, null or white space.</exception>
      <exception cref="T:System.UnauthorizedAccessException">The named semaphore exists, but the user does not have the minimum needed security access rights to use it.</exception>
    </member>
    <member name="T:Gemstone.Threading.InterprocessReaderWriterLock">
      <summary>
            Represents an inter-process reader/writer lock using <see cref="T:Gemstone.Threading.NamedSemaphore" /> and <see cref="T:System.Threading.Mutex" />
            native locking mechanisms.
            </summary>
      <remarks>
        <para>
            The <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> uses a <see cref="T:Gemstone.Threading.NamedSemaphore" /> to synchronize access to an inter-process shared resource.
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore" /> exhibits kernel persistence, meaning instances will remain active beyond the lifespan of
            the creating process. The named semaphore must be explicitly removed by invoking <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources" /> when the last
            reader-writer lock instance is no longer needed. Kernel persistence necessitates careful design consideration regarding process
            responsibility for invoking the <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources" /> method. Since the common use case for named semaphores is across
            multiple applications, it is advisable for the last exiting process to handle the cleanup. In cases where an application may crash before
            calling the <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources" /> method, the semaphore persists in the system, potentially leading to resource leakage.
            Implementations should include strategies to address and mitigate this risk.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Boolean)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> associated with the specified
            <paramref name="name" /> that identifies a source object needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="global">Determines if semaphore and mutex used by <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> should be marked as global; set value to <c>false</c> for local.</param>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.#ctor(System.String,System.Int32,System.Boolean)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> associated with the specified
            <paramref name="name" /> that identifies a source object needing concurrency locking.
            </summary>
      <param name="name">Identifying name of source object needing concurrency locking (e.g., a path and file name).</param>
      <param name="maximumConcurrentLocks">Maximum concurrent reader locks to allow.</param>
      <param name="global">Determines if semaphore and mutex used by <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> should be marked as global; set value to <c>false</c> for local.</param>
      <remarks>
            If more reader locks are requested than the <paramref name="maximumConcurrentLocks" />, excess reader locks will simply
            wait until a lock is available (i.e., one of the existing reads completes).
            </remarks>
    </member>
    <member name="F:Gemstone.Threading.InterprocessReaderWriterLock.DefaultMaximumConcurrentLocks">
      <summary>
            Default maximum concurrent locks allowed for <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose">
      <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> object.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> object and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock">
      <summary>
            Tries to enter the lock in read mode.
            </summary>
      <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock">
      <summary>
            Tries to enter the lock in write mode.
            </summary>
      <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock">
      <summary>
            Exits read mode and returns the prior read lock count.
            </summary>
      <returns>
        <markup>
          <include item="SMCMissingTag">
            <parameter>returns</parameter>
            <parameter>M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock</parameter>
          </include>
        </markup>
      </returns>
      <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock">
      <summary>
            Exits write mode.
            </summary>
      <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.Finalize">
      <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" /> object is reclaimed by <see cref="T:System.GC" />.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.InterprocessReaderWriterLock.MaximumConcurrentLocks">
      <summary>
            Gets the maximum concurrent reader locks allowed.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.ReleaseInterprocessResources">
      <summary>
            Releases inter-process resources used by the <see cref="T:Gemstone.Threading.InterprocessReaderWriterLock" />.
            </summary>
      <remarks>
            On POSIX systems, calling this method removes the named semaphore used by the reader-writer lock.
            The semaphore name is removed immediately and is destroyed once all other processes that have the
            semaphore open close it. Calling this method on Windows systems does nothing.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)">
      <summary>
            Tries to enter the lock in read mode, with an optional time-out.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</param>
      <returns>
        <c>true</c> if the calling thread entered read mode, otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterReadLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterReadLock(System.Int32)" />.
            </para>
        <para>
            Note that this function may wait as long as 2 * <paramref name="millisecondsTimeout" /> since the function first waits for synchronous access
            to the semaphore, then waits again on an available semaphore slot.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)">
      <summary>
            Tries to enter the lock in write mode, with an optional time-out.
            </summary>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</param>
      <returns>
        <c>true</c> if the calling thread entered write mode, otherwise, <c>false</c>.</returns>
      <remarks>
        <para>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.EnterWriteLock" /> or <see cref="M:Gemstone.Threading.InterprocessReaderWriterLock.TryEnterWriteLock(System.Int32)" />.
            </para>
        <para>
            Note that this function may wait as long as 2 * <paramref name="millisecondsTimeout" /> since the function first waits for synchronous access
            to the semaphore, then waits again on an available semaphore slot.
            </para>
      </remarks>
    </member>
    <member name="T:Gemstone.Threading.NamedSemaphore">
      <summary>
            Represents a cross-platform, interprocess named semaphore, which limits the number of threads that can concurrently 
            access a resource or a pool of resources.
            </summary>
      <remarks>
        <para>
            A <see cref="T:Gemstone.Threading.NamedSemaphore" /> is a synchronization object that can be utilized across multiple processes.
            </para>
        <para>
            On POSIX systems, the <see cref="T:Gemstone.Threading.NamedSemaphore" /> exhibits kernel persistence, meaning instances will remain
            active beyond the lifespan of the creating process. Named semaphores must be explicitly removed by invoking 
            <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" /> when they are no longer needed. Kernel persistence necessitates careful design consideration
            regarding the responsibility for invoking <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" />. Since the common use case for named semaphores is
            across multiple applications, it is advisable for the last exiting process to handle the cleanup. In cases where
            an application may crash before calling <see cref="M:Gemstone.Threading.NamedSemaphore.Unlink" />, the semaphore persists in the system, potentially
            leading to resource leakage. Implementations should include strategies to address and mitigate this risk.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.#ctor(System.Int32,System.Int32,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Threading.NamedSemaphore" /> class, specifying the initial number of entries,
            the maximum number of concurrent entries, and the name of a system semaphore object.
            </summary>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
      <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
      <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
      <remarks>
            The <paramref name="name" /> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)">
      <summary>
            Initializes a new instance of the <see cref="T:Gemstone.Threading.NamedSemaphore" /> class, specifying the initial number of entries,
            the maximum number of concurrent entries, the name of a system semaphore object, and specifying a variable that
            receives a value indicating whether a new system semaphore was created.
            </summary>
      <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
      <param name="maximumCount">The maximum number of requests for the semaphore that can be granted concurrently.</param>
      <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
      <param name="createdNew">
            When method returns, contains <c>true</c> if the specified named system semaphore was created; otherwise,
            <c>false</c> if the semaphore already existed.
            </param>
      <remarks>
            The <paramref name="name" /> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.Close">
      <summary>
            Releases all resources held by the current <see cref="T:Gemstone.Threading.NamedSemaphore" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.Dispose(System.Boolean)">
      <summary>
            When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.NamedSemaphore" />,
            and optionally releases the managed resources.
            </summary>
      <param name="explicitDisposing">
        <c>true</c> to release both managed and unmanaged resources; otherwise, <c>false</c> to release only
            unmanaged resources.
            </param>
    </member>
    <member name="P:Gemstone.Threading.NamedSemaphore.Name">
      <summary>
            Gets the name of the <see cref="T:Gemstone.Threading.NamedSemaphore" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.OpenExisting(System.String)">
      <summary>
            Opens an existing named semaphore.
            </summary>
      <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
      <returns>
            An object that represents the opened named semaphore.
            </returns>
      <remarks>
            The <paramref name="name" /> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.Release">
      <summary>
            Exits the semaphore and returns the previous count.
            </summary>
      <returns>The count on the semaphore before the method was called.</returns>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.Release(System.Int32)">
      <summary>
            Exits the semaphore a specified number of times and returns the previous count.
            </summary>
      <param name="releaseCount">The number of times to exit the semaphore.</param>
      <returns>The count on the semaphore before the method was called.</returns>
    </member>
    <member name="P:Gemstone.Threading.NamedSemaphore.SafeWaitHandle">
      <summary>
            Gets or sets the native operating system handle.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.TryOpenExisting(System.String,Gemstone.Threading.NamedSemaphore@)">
      <summary>
            Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the
            operation succeeded.
            </summary>
      <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
      <param name="semaphore">
            When this method returns, contains a <see cref="T:Gemstone.Threading.NamedSemaphore" /> object that represents the named semaphore
            if the call succeeded, or <c>null</c> if the call failed. This parameter is treated as uninitialized.
            </param>
      <returns>
        <c>true</c> if the named semaphore was opened successfully; otherwise, <c>false</c>. In some cases,
            <c>false</c> may be returned for invalid names.
            </returns>
      <remarks>
            The <paramref name="name" /> may be prefixed with <c>Global\</c> or <c>Local\</c> to specify a namespace.
            When the Global namespace is specified, the synchronization object may be shared with any processes on the system.
            When the Local namespace is specified, which is also the default when no namespace is specified, the synchronization
            object may be shared with processes in the same session. On Windows, a session is a login session, and services
            typically run in a different non-interactive session. On Unix-like operating systems, each shell has its own session.
            Session-local synchronization objects may be appropriate for synchronizing between processes with a parent/child
            relationship where they all run in the same session.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.Unlink">
      <summary>
            Removes a named semaphore.
            </summary>
      <remarks>
            On POSIX systems, calling this method removes the named semaphore referred to by <see cref="P:Gemstone.Threading.NamedSemaphore.Name" />.
            The semaphore name is removed immediately and is destroyed once all other processes that have the semaphore
            open close it. Calling this method on Windows systems does nothing.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.Unlink(System.String)">
      <summary>
            Removes a named semaphore.
            </summary>
      <param name="name">
            The unique name identifying the semaphore. This name is case-sensitive. Use a backslash (\\) to specify a
            namespace, but avoid it elsewhere in the name. On Unix-based systems, the name should conform to valid file
            naming conventions, excluding slashes except for an optional namespace backslash. The name length is limited
            to 250 characters after any optional namespace.
            </param>
      <remarks>
            On POSIX systems, calling this method removes the named semaphore referred to by <paramref name="name" />.
            The semaphore name is removed immediately and is destroyed once all other processes that have the semaphore
            open close it. Calling this method on Windows systems does nothing.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne">
      <summary>
            Blocks the current thread until the current <see cref="T:Gemstone.Threading.NamedSemaphore" /> receives a signal.
            </summary>
      <returns>
        <c>true</c> if the current instance receives a signal. If the current instance is never signaled,
            <see cref="T:Gemstone.Threading.NamedSemaphore" /> never returns.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.Int32)">
      <summary>
            Blocks the current thread until the current instance receives a signal, using a 32-bit signed integer to
            specify the time interval in milliseconds.
            </summary>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.
            </param>
      <returns>
        <c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.Int32,System.Boolean)">
      <summary>
            Blocks the current thread until the current <see cref="T:Gemstone.Threading.NamedSemaphore" /> receives a signal, using a
            32-bit signed integer to specify the time interval and specifying whether to exit the synchronization
            domain before the wait.
            </summary>
      <param name="millisecondsTimeout">
            The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.
            </param>
      <param name="exitContext">
        <c>true</c> to exit the synchronization domain for the context before the wait (if in a synchronized context),
            and reacquire it afterward; otherwise, <c>false</c>.
            </param>
      <returns>
        <c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.TimeSpan)">
      <summary>
            Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" />
            to specify the time interval.
            </summary>
      <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" />
            that represents -1 milliseconds to wait indefinitely.
            </param>
      <returns>
        <c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Gemstone.Threading.NamedSemaphore.WaitOne(System.TimeSpan,System.Boolean)">
      <summary>
            Blocks the current thread until the current instance receives a signal, using a <see cref="T:System.TimeSpan" />
            to specify the time interval and specifying whether to exit the synchronization domain before the wait.
            </summary>
      <param name="timeout">
            A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" />
            that represents -1 milliseconds to wait indefinitely.
            </param>
      <param name="exitContext">
        <c>true</c> to exit the synchronization domain for the context before the wait (if in a synchronized context),
            and reacquire it afterward; otherwise, <c>false</c>.
            </param>
      <returns>
        <c>true</c> if the current instance receives a signal; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.RateLimiter">
      <summary>
            A rate limiting system based on tokes.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.RateLimiter.#ctor(System.Double,System.Int32)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.RateLimiter" /></summary>
      <param name="tokensPerSecond">The number of tokens per second that can be generated. Must be greater than zero and less than 1 billion</param>
      <param name="maxTokensQueue">The maximum number of tokens in the queue. Must be at least 1</param>
    </member>
    <member name="M:Gemstone.Threading.RateLimiter.TryTakeToken">
      <summary>
            Attempts to take a token from the rate limiter.
            </summary>
      <returns>true if token was successfully taken, False if all tokens were consumed.</returns>
    </member>
    <member name="M:Gemstone.Threading.RateLimiter.UpdateLimits(System.Double,System.Int32)">
      <summary>
            Updates the limits associated with this rate limiter. Note, after this update, the tokens will be completely resupplied.
            </summary>
      <param name="tokensPerSecond">The number of tokens per second that can be generated. Must be greater than zero and less than 1 billion</param>
      <param name="maxTokensQueue">The maximum number of tokens in the queue. Must be at least 1</param>
    </member>
    <member name="T:Gemstone.Threading.ReaderWriterSpinLock">
      <summary>
            Represents a fast, lightweight reader/writer lock that uses spinning to perform locking. No recursive acquires or
            upgradable locks are allowed (i.e., all entered locks must be exited before entering another lock).
            </summary>
      <remarks>
            This reader/writer lock uses <see cref="T:System.Threading.SpinWait" /> to spin the CPU instead of engaging event based locking. As a result it
            should only be used in cases where lock times are expected to be very small, reads are very frequent and writes are rare.
            If hold times for write locks can be lengthy, it will be better to use <see cref="T:System.Threading.ReaderWriterLockSlim" /> instead to avoid
            unnecessary CPU utilization due to spinning incurred by waiting reads.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.#ctor">
      <summary>
        <markup>
          <include item="SMCAutoDocConstructor">
            <parameter>Gemstone.Threading.ReaderWriterSpinLock</parameter>
          </include>
        </markup>
      </summary>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.EnterReadLock">
      <summary>
            Enters the lock in read mode.
            </summary>
      <remarks>
            Upon successful acquisition of a read lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock" />.
            One <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock" /> should be called for each <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.EnterReadLock" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.EnterWriteLock">
      <summary>
            Enters the lock in write mode.
            </summary>
      <remarks>
            Upon successful acquisition of a write lock, use the <c>finally</c> block of a <c>try/finally</c> statement to call <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock" />.
            One <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock" /> should be called for each <see cref="M:Gemstone.Threading.ReaderWriterSpinLock.EnterWriteLock" />.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.ExitReadLock">
      <summary>
            Exits read mode.
            </summary>
      <exception cref="T:System.InvalidOperationException">Cannot exit read lock when there are no readers.</exception>
    </member>
    <member name="M:Gemstone.Threading.ReaderWriterSpinLock.ExitWriteLock">
      <summary>
            Exits write mode.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.ScheduledTask">
      <summary>
            Represents a way to schedule a task to be executed on a separate thread immediately or after a given time delay.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.#ctor(Gemstone.Threading.ThreadingMode,System.Threading.ThreadPriority,System.Boolean)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.ScheduledTask" />.
            </summary>
      <param name="threadMode">The manner in which the scheduled task executes.</param>
      <param name="priority">The thread priority to assign if a dedicated thread is used. This is ignored if using the thread-pool.</param>
      <param name="disposeOnShutdown">Adds a handler to <see cref="T:Gemstone.Threading.ShutdownHandler" /> that requires this class to be disposed
            when the application is shutdown. Note: If this object has been garbage collected, this will have no effect.</param>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Dispose">
      <summary>
            Starts the disposing process of exiting the worker thread. 
            </summary>
      <remarks>
        <para>Callback will be invoked one more time. Duplicate calls are ignored.</para>
        <para>
            Unless called from the worker thread, this method will block until the dispose
            has successfully completed.
            </para>
      </remarks>
    </member>
    <member name="E:Gemstone.Threading.ScheduledTask.Disposing">
      <summary>
            Occurs right before this task is disposed.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Finalize">
      <summary>
            Cleans up the <see cref="T:Gemstone.Threading.ThreadContainerBase" /> thread since that class likely will never be garbage collected.
            </summary>
    </member>
    <member name="E:Gemstone.Threading.ScheduledTask.Running">
      <summary>
            Occurs every time the task should run.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Start">
      <summary>
            Starts the task immediately, or if one was scheduled, starts the scheduled task immediately
            </summary>
      <remarks>
        <para>
            If this is called after a <see cref="M:Gemstone.Threading.ScheduledTask.Start(System.Int32)" /> the timer will be canceled
            and the process will still start immediately. 
            </para>
        <para>
            This method is safe to call from any thread, including the worker thread.
            If disposed, this method will no nothing.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.ScheduledTask.Start(System.Int32)">
      <summary>
            Starts a timer to run the task after a provided interval. 
            </summary>
      <param name="delay">the delay in milliseconds before the task should run</param>
      <remarks>
        <para>
            If a timer is currently pending, this function will do nothing. Do not use this
            function to reset or restart an existing timer.
            </para>
        <para>
            If called while working, a subsequent timer will be scheduled, but delay will not
            start until after the worker has completed.
            </para>
        <para>
            This method is safe to call from any thread, including the worker thread.
            If disposed, this method will no nothing.
            </para>
      </remarks>
    </member>
    <member name="T:Gemstone.Threading.ScheduledTaskRunningReason">
      <summary>
            Metadata about why this worker was called.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ScheduledTaskRunningReason.Running">
      <summary>
            A normal run was scheduled.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ScheduledTaskRunningReason.Disposing">
      <summary>
            Dispose was called and execution will terminate after this function call.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SharedTimer">
      <summary>
            Represents a timer class that will group registered timer event callbacks that operate on the same
            interval in order to optimize thread pool queuing.
            </summary>
      <remarks>
        <para>
            Externally the <see cref="T:Gemstone.Threading.SharedTimer" /> operations similar to the <see cref="T:System.Timers.Timer" />.
            Internally the timer pools callbacks with the same <see cref="P:Gemstone.Threading.SharedTimer.Interval" /> into a single timer where
            each callback is executed on the same thread, per instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler" />. 
            </para>
        <para>
            Any long running callbacks that have a risk of long delays should not use <see cref="T:Gemstone.Threading.SharedTimer" />
            as this will effect the reliability of all of the other <see cref="T:Gemstone.Threading.SharedTimer" /> instances for a
            given <see cref="T:Gemstone.Threading.SharedTimerScheduler" />.
            </para>
      </remarks>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.AutoReset">
      <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only
            once <c>false</c> or repeatedly <c>true</c>.
            </summary>
      <returns>
        <c>true</c> the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event each time the interval elapses; otherwise,
            <c>false</c> if it should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event only once, after the first time the interval elapses.
            The default is <c>true</c>.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Close">
      <summary>
            Stops the timer.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Dispose">
      <summary>
            Stops the timer and prevents reuse of the class.
            </summary>
    </member>
    <member name="E:Gemstone.Threading.SharedTimer.Elapsed">
      <summary>
            Occurs when the timer interval elapses.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Enabled">
      <summary>
            Gets or sets flag that indicates whether the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
      <returns>
        <c>true</c> if the <see cref="T:Gemstone.Threading.SharedTimer" /> should raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event; otherwise, <c>false</c>.
            The default is <c>false</c>.
            </returns>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Interval">
      <summary>
            Gets or sets the interval at which to raise the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event.
            </summary>
      <returns>The time, in milliseconds, between <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> events.</returns>
      <remarks>
            The value must be greater than zero, and less than or equal to <see cref="F:System.Int32.MaxValue" />.
            The default is 100 milliseconds.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Start">
      <summary>
            Starts raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>true</c>.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimer.Status">
      <summary>
            Gets the current status details about object providing status information.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimer.Stop">
      <summary>
            Stops raising the <see cref="E:Gemstone.Threading.SharedTimer.Elapsed" /> event by setting <see cref="P:Gemstone.Threading.SharedTimer.Enabled" /> to <c>false</c>.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SharedTimerScheduler">
      <summary>
            Represents a timer manager which is the scheduler of <see cref="T:Gemstone.Threading.SharedTimer" />.
            </summary>
      <remarks>
            A <see cref="T:Gemstone.Threading.SharedTimer" /> with the same scheduler will use the same ThreadPool thread to process
            all of the <see cref="T:Gemstone.Threading.SharedTimer" /> instances in series when they have a common interval. Call
            order, based on registration sequence, will be preserved.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SharedTimerScheduler" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.CreateTimer(System.Int32)">
      <summary>
            Creates a <see cref="T:Gemstone.Threading.SharedTimer" /> using the current <see cref="T:Gemstone.Threading.SharedTimerScheduler" />.
            </summary>
      <param name="interval">The interval of the timer, default is 100.</param>
      <returns>A shared timer instance that fires at the given interval.</returns>
    </member>
    <member name="M:Gemstone.Threading.SharedTimerScheduler.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SharedTimerScheduler.IsDisposed">
      <summary>
            Gets flag that determines if this <see cref="T:Gemstone.Threading.SharedTimerScheduler" /> instance has been disposed.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.TaskCompletionSourceFactory">
      <summary>
            Provides factory functions for creating new
            <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> objects.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1">
      <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> class.
            </summary>
      <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
      <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.TaskCompletionSourceFactory.CreateNew``1(System.Object)">
      <summary>
            Creates a new instance of the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> class.
            </summary>
      <param name="state">The state to use as the underlying <see cref="T:System.Threading.Tasks.Task" />'s <see cref="P:System.Threading.Tasks.Task.AsyncState" />.</param>
      <typeparam name="T">The type of the result value associated with the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
      <returns>A new object of type <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</returns>
    </member>
    <member name="F:Gemstone.Threading.TaskCompletionSourceFactory.DefaultTaskCreationOptions">
      <summary>
            The default <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used by this factory
            for creating new <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> objects.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.ThreadingMode">
      <summary>
            Specifies the threading mode to use for the <see cref="T:Gemstone.Threading.ScheduledTask" /></summary>
    </member>
    <member name="F:Gemstone.Threading.ThreadingMode.DedicatedForeground">
      <summary>
            A dedicated thread that is a foreground thread.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ThreadingMode.DedicatedBackground">
      <summary>
            A dedicated thread that is a background thread.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.ThreadingMode.ThreadPool">
      <summary>
            A background thread from the thread pool.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.WeakAction">
      <summary>
            Provides a weak referenced <see cref="T:System.Action" /> delegate.
            </summary>
      <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.#ctor(System.Action)">
      <summary>
            Creates a WeakAction.
            </summary>
      <param name="callback">The callback.</param>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.Clear">
      <summary>
            Clears <see cref="T:System.Action" /> callback target.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.WeakAction.TryInvoke">
      <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.WeakAction`1">
      <summary>
            Provides a weak referenced <see cref="T:System.Action" /> delegate.
            </summary>
      <typeparam name="T">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>typeparam</parameter>
            <parameter>T</parameter>
            <parameter>T:Gemstone.Threading.WeakAction`1</parameter>
          </include>
        </markup>
      </typeparam>
      <remarks>
            This class will store the information necessary so the callback
            object will have a weak reference to it. This information is compiled
            an can be quickly executed without the overhead of using reflection.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.#ctor(System.Action{`0})">
      <summary>
            Creates a WeakAction.
            </summary>
      <param name="callback">The callback.</param>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.Clear">
      <summary>
            Clears <see cref="T:System.Action" /> callback target.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.WeakAction`1.TryInvoke(`0)">
      <summary>
            Attempts to invoke the delegate to a weak reference object.
            </summary>
      <param name="param1">
        <markup>
          <include item="SMCMissingParamTag">
            <parameter>param</parameter>
            <parameter>param1</parameter>
            <parameter>M:Gemstone.Threading.WeakAction`1.TryInvoke(`0)</parameter>
          </include>
        </markup>
      </param>
      <returns>
        <c>true</c> if successful; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1">
      <summary>
            Combines <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" /> and <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> to provide
            a low-contention, double-buffered queue suitable for multiple-producer, single-consumer
            scenarios.
            </summary>
      <typeparam name="T">Type of items being queued.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1" /> class.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Count">
      <summary>
            Gets the number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Enqueues a collection of items into the async double-buffered queue.
            </summary>
      <param name="items">The items to be queued.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncDoubleBufferedQueue`1.ProcessItemsFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.AsyncQueue`1">
      <summary>
            Creates a fast, light-weight asynchronous processing queue with very low contention.
            </summary>
      <typeparam name="T">Type of items to process.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor">
      <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType)">
      <summary>
            Creates a new <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <param name="synchronizedOperationType">The type of synchronized operation to use to process items in the queue.</param>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Count">
      <summary>
            Gets the total number of items currently in the queue.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.Enabled">
      <summary>
            Gets or sets flag that enables or disables processing.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.AsyncQueue`1.Enqueue(`0)">
      <summary>
            Enqueues an item for processing.
            </summary>
      <param name="item">Item to be queued for processing.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.AsyncQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.AsyncQueue`1.ProcessItemFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1">
      <summary>
            A thread-safe double-buffered queue that allows for low-contention
            item processing in single-producer, single-consumer scenarios.
            </summary>
      <typeparam name="T">Type of items being queued.</typeparam>
      <remarks>
            It is not safe to use this class with multiple consumer threads.
            The <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue" /> method must be called by one thread at
            a time, and the consumer must not access a list returned by Dequeue
            after its next call to Dequeue.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Clear">
      <summary>
            Empties the producer's buffer so that the
            items can no longer be consumed by the consumer.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Count">
      <summary>
            Gets the current number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Dequeue">
      <summary>
            Dequeues a collection of items from the queue.
            </summary>
      <returns>
            A collection of items that have previously been enqueued,
            or no items if none have been enqueued since last dequeue.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.Enqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Enqueues a collection of items into the double-buffered queue.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
    </member>
    <member name="E:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessException">
      <summary>
            Event that is raised if an exception is encountered while attempting to processing an item in the <see cref="T:Gemstone.Threading.Collections.AsyncQueue`1" />.
            </summary>
      <remarks>
            Processing will not stop for any exceptions thrown by user processing function, but exceptions will be exposed through this event.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueue`1.ProcessItemsFunction">
      <summary>
            Gets or sets item processing function.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryClear">
      <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
      <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryDequeue(System.Collections.Generic.IList{`0}@)">
      <summary>
            Attempts to dequeue a collection of items from the queue and
            returns the number of items left in the queue after dequeuing.
            </summary>
      <param name="items">The items that were dequeued.</param>
      <returns>
            The number of items left in the queue after
            dequeuing as many items as possible.
            </returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueue`1.TryEnqueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Attempts to enqueue a collection of items into the double-buffered queue.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
      <returns>
            True if the items were successfully enqueued; false otherwise.
            </returns>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1">
      <summary>
            Manages queues to reduce contention for a multi-threaded, multiple-producer, single-consumer scenario.
            </summary>
      <typeparam name="T">The types of items to be queued.</typeparam>
      <remarks>
            For best results, each thread that is producing items to the consumer should call
            <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer" /> to receive a producer object that will not contend with
            any other producer. The consumer should either provide a handler to process the queued
            items or poll the manager by calling <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue" /> (not both!). It is not
            safe to use this class with multiple consumer threads.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
      <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.#ctor(System.Action{System.Collections.Generic.IList{`0}},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" /> class.
            </summary>
      <param name="itemHandler">The method to handle processing of queued items.</param>
      <param name="exceptionHandler">The method to handle exceptions that occur when processing items.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue">
      <summary>
            Dequeues a list of items produced by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" />s.
            </summary>
      <returns>A list of items to be consumed.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.GetProducer">
      <summary>
            Creates a producer used to produce items to the consumer of this <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1" />.
            </summary>
      <returns>A <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> used to produce items to the consumer.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.ItemsLeft">
      <summary>
            Gets a flag that indicates whether there are any items left to
            be consumed after the last call to <see cref="M:Gemstone.Threading.Collections.DoubleBufferedQueueManager`1.Dequeue" />.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1">
      <summary>
            A producer for a <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueue`1" /> which can
            only be used to provide items to the queue for consumption.
            </summary>
      <typeparam name="T">The type of the items produced to the queue.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose">
      <summary>
            Releases all the resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Finalize">
      <summary>
            Releases the unmanaged resources before the <see cref="T:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1" /> object is reclaimed by <see cref="T:System.GC" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.DoubleBufferedQueueProducer`1.Produce(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Produces a collection of items to be processed by the consumer.
            </summary>
      <param name="items">The collection of items to be enqueued.</param>
    </member>
    <member name="T:Gemstone.Threading.Collections.PriorityQueue`1">
      <summary>
            Represents a thread-safe prioritized first in-first out (FIFO) collection.
            </summary>
      <typeparam name="T">The type of elements contained in the queue.</typeparam>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(Gemstone.Threading.Collections.PriorityQueue{`0})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
      <param name="priorityQueue">Another priority queue of items to be enqueued in this queue at the same priority.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priorityQueue" /> queue length is less than or equal to 0.</exception>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="priorityQueue" /> is <c>null</c>.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> class.
            </summary>
      <param name="priorityLevels">The number of priority levels to preallocate in the queue.</param>
      <exception cref="T:System.ArgumentException">
        <paramref name="priorityLevels" /> is less than or equal to 0.</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> elements to an existing
            one-dimensional <see cref="T:System.Array" />, starting at the specified array index.
            </summary>
      <param name="array">
            The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
            from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />. The <see cref="T:System.Array" /> must
            have zero-based indexing.
            </param>
      <param name="index">The zero-based index in array at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">array is a null reference (Nothing in Visual Basic).</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero.</exception>
      <exception cref="T:System.ArgumentException">
            index is equal to or greater than the length of the array -or- The number of
            elements in the source <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> is greater
            than the available space from index to the end of the destination array.
            </exception>
    </member>
    <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.Count">
      <summary>
            Gets the number of items in the queue.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.Enqueue(`0,System.Int32)">
      <summary>
            Enqueues an item into the priority queue.
            </summary>
      <param name="item">The item to be enqueued.</param>
      <param name="priority">The priority at which the item should be queued. Larger numbers have higher priority!</param>
      <remarks>
            This priority queue is implemented using an array of <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.
            The array index indicates the priority of tasks in each queue. For best performance,
            ensure that your code defines all priority levels consecutively, starting from 0.
            </remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is negative</exception>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.
            </summary>
      <returns>An enumerator for the contents of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.</returns>
    </member>
    <member name="P:Gemstone.Threading.Collections.PriorityQueue`1.IsEmpty">
      <summary>
            Indicates whether the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> is empty.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.ToArray">
      <summary>
            Copies the elements stored in the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> to a new array.
            </summary>
      <returns>A new array containing a snapshot of elements copied from the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" />.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(System.Int32,`0@)">
      <summary>
            Dequeues an item from the priority queue.
            </summary>
      <param name="priority">The priority at which the item should be dequeued.</param>
      <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
      <returns>True if an item was dequeued; false if the queue is empty.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryDequeue(`0@)">
      <summary>
            Dequeues an item from the priority queue.
            </summary>
      <param name="result">The item that was dequeued, or the default value if no item was dequeued.</param>
      <returns>True if an item was dequeued; false if the queue is empty.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(System.Int32,`0@)">
      <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> without removing it.
            </summary>
      <param name="priority">The priority at which to peek into the queue.</param>
      <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> or an unspecified value if the operation failed.
            </param>
      <returns>true if an object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="M:Gemstone.Threading.Collections.PriorityQueue`1.TryPeek(`0@)">
      <summary>
            Tries to return an object from the beginning of the <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> without removing it.
            </summary>
      <param name="result">
            When this method returns, result contains an object from the beginning of the
            <see cref="T:Gemstone.Threading.Collections.PriorityQueue`1" /> or an unspecified value if the operation failed.
            </param>
      <returns>true if an object was returned successfully; otherwise, false.</returns>
    </member>
    <member name="T:Gemstone.Threading.Strands.PriorityStrand">
      <summary>
            Schedules tasks in a collection of FIFO queues and executes them in priority order.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory,System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
      <param name="priorityLevels">The number of priority levels to be preallocated by the priority queue.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.#ctor(System.Int32)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.PriorityStrand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
      <param name="priorityLevels">The number of priority levels to be preallocated by the priority queue.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.PriorityStrand.GetScheduler(System.Int32)">
      <summary>
            Gets a <see cref="T:System.Threading.Tasks.TaskScheduler" /> used to queue tasks at a specific priority.
            </summary>
      <param name="priority">The priority at which tasks should be queued by the returned <see cref="T:System.Threading.Tasks.TaskScheduler" />. Higher numbers are higher in priority!</param>
      <returns>A <see cref="T:System.Threading.Tasks.TaskScheduler" /> that queues tasks into the strand at the given priority.</returns>
      <remarks>For a strand with <c>n</c> priorities, it is recommended to use priority levels between <c>0</c> and <c>n-1</c> inclusive.</remarks>
      <exception cref="T:System.ArgumentException">
        <paramref name="priority" /> is less than zero</exception>
    </member>
    <member name="T:Gemstone.Threading.Strands.Strand">
      <summary>
            Schedules tasks in a FIFO queue and executes them in a synchronized asynchronous loop.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.#ctor">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand" /> class with a <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.#ctor(Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.Strands.Strand" /> class.
            </summary>
      <param name="synchronizedOperationFactory">Factory function for creating the synchronized operation to be used for processing tasks.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.GetScheduledTasks">
      <summary>
            For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" />
            instances currently queued to the scheduler waiting to be executed.
            </summary>
      <returns>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</returns>
    </member>
    <member name="P:Gemstone.Threading.Strands.Strand.MaximumConcurrencyLevel">
      <summary>
            Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.QueueTask(System.Threading.Tasks.Task)">
      <summary>
            Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</param>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.TryDequeue(System.Threading.Tasks.Task)">
      <summary>
            Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</param>
      <returns>A Boolean denoting whether the task argument was successfully dequeued.</returns>
    </member>
    <member name="M:Gemstone.Threading.Strands.Strand.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
      <summary>
            Attempts to executes a task inline, but only if this method is
            called on the processing thread to avoid parallel execution of tasks.
            </summary>
      <param name="task">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</param>
      <param name="taskWasPreviouslyQueued">
            A Boolean denoting whether or not task has previously been queued.
            If this parameter is True, then the task may have been previously queued (scheduled);
            if False, then the task is known not to have been queued,
            and this call is being made in order to execute the task inline without queuing it.
            </param>
      <returns>A Boolean value indicating whether the task was executed inline.</returns>
      <remarks>
            Inline execution allows tasks to skip the line and run out of order.
            The only reason inline execution is supported at all is to avoid a common
            case of deadlocking where a task is queued in advance of another task that it
            depends on (via <see cref="M:System.Threading.Tasks.Task.Wait" />, for instance). However, deadlocks can
            still occur when waiting on tasks scheduled by a different strand. To avoid
            out-of-order execution and deadlocks, be very careful about using API calls
            that wait on tasks.
            </remarks>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation">
      <summary>
            Represents a short-running synchronized operation that cannot run while it is already
            in progress. Async operations will execute on the thread-pool after the specified
            <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds.
            </summary>
      <remarks>
            By default, the action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />
            is executed on the <see cref="T:System.Threading.ThreadPool" /> when running the operation asynchronously.
            When the operation is set to pending, the action is executed in an asynchronous loop on
            the thread pool until all pending operations have been completed. Since the action is
            executed on the thread pool, it is best if it can be executed quickly, without
            blocking the thread or putting it to sleep. If completion of the operation is
            critical, such as when saving data to a file, this type of operation should not
            be used since thread pool threads are background threads and will not prevent the
            program from ending before the operation is complete.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay">
      <summary>
            Defines the default value for the <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> property.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay">
      <summary>
            Gets or sets the amount of time to wait before execution, in milliseconds,
            for any asynchronous calls. Zero value will execute immediately.
            </summary>
      <remarks>
            Non asynchronous calls will not be delayed.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.ExecuteActionAsync">
      <summary>
            Executes the action on a separate thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" />.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Factory(System.Action)">
      <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" /> signature.
            </summary>
      <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.</param>
      <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" /> with <see cref="F:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.DefaultDelay" /> of 1000 milliseconds.</returns>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Run(System.Boolean)">
      <summary>
            Executes the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds or marks
            the operation as pending if the operation is already running. Method same as <see cref="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync" /> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </summary>
      <param name="runPendingSynchronously">
            Defines synchronization mode for running any pending operation; must be <c>false</c> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </param>
      <remarks>
        <para>
            For <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />, actions will always run on another thread so this method is
            hidden from intellisense.
            </para>
        <para>
            When the operation is marked as pending, it will run again after the operation that is currently running
            has completed. This is useful if an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="runPendingSynchronously" /> must be <c>false</c> for <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </exception>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.RunAsync">
      <summary>
            Executes the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds or marks
            the operation as pending if the operation is already running
            </summary>
      <remarks>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRun(System.Boolean)">
      <summary>
            Attempts to execute the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds.
            Does nothing if the operation is already running. Method same as <see cref="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync" /> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </summary>
      <param name="runPendingSynchronously">
            Defines synchronization mode for running any pending operation; must be <c>false</c> for
            <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </param>
      <remarks>
            For <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />, actions will always run on another thread so this method is
            hidden from intellisense.
            </remarks>
      <exception cref="T:System.InvalidOperationException">
        <paramref name="runPendingSynchronously" /> must be <c>false</c> for <see cref="T:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation" />.
            </exception>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread after the specified <see cref="P:Gemstone.Threading.SynchronizedOperations.DelayedSynchronizedOperation.Delay" /> in milliseconds.
            Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation">
      <summary>
            Represents an operation that cannot run while it is already in progress.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.CancellationToken">
      <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken" /> to use for canceling actions.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsPending">
      <summary>
            Gets flag indicating if the synchronized operation has an additional operation that is pending
            execution after the currently running action has completed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.IsRunning">
      <summary>
            Gets flag indicating if the synchronized operation is currently executing its action.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.Run(System.Boolean)">
      <summary>
            Executes the action on current thread or marks the operation as pending if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
        <para>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </para>
        <para>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.RunAsync">
      <summary>
            Executes the action on another thread or marks the operation as pending if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, it will run again after the operation that is currently running
            has completed. This is useful if an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRun(System.Boolean)">
      <summary>
            Attempts to execute the action on current thread. Does nothing if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread. Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation">
      <summary>
            Represents a long-running synchronized operation that cannot run while it is already in progress.
            </summary>
      <remarks>
            The action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> is executed on
            its own dedicated thread when running the operation in the foreground asynchronously.
            When running on its own thread, the action is executed in a tight loop until all
            pending operations have been completed. This type of synchronized operation should
            be preferred if operations may take a long time, block the thread, or put it to sleep.
            It is also recommended to prefer this type of operation if the speed of the operation
            is not critical or if completion of the operation is critical, such as when saving data
            to a file.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The cancellable action to be performed if an exception is thrown from the action.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.ExecuteActionAsync">
      <summary>
            Executes the action on a separate thread.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.Factory(System.Action)">
      <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" /> signature.
            </summary>
      <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />.</param>
      <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />.</returns>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation.IsBackground">
      <summary>
            Gets or sets whether or not the thread executing the action is a background thread.
            </summary>
      <remarks>
            This defaults to <c>false</c>, be aware that foreground thread will prevent shutdown
            while task is running. If a task keeps getting marked as pending, application will not
            shutdown; consider a cancellable action for <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />
            instances that use a foreground thread.
            </remarks>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation">
      <summary>
            Represents a short-running synchronized operation that cannot run while it is already in progress.
            </summary>
      <remarks>
            By default, the action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />
            is executed on the <see cref="T:System.Threading.ThreadPool" /> when running the operation asynchronously.
            When the operation is set to pending, the action is executed in an asynchronous loop
            on the thread pool until all pending operations have been completed. Since the action
            is executed on the thread pool, it is best if it can be executed quickly, without
            blocking the thread or putting it to sleep. If completion of the operation is
            critical, such as when saving data to a file, this type of operation should not
            be used since thread pool threads are background threads and will not prevent the
            program from ending before the operation is complete.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.ExecuteActionAsync">
      <summary>
            Executes the action in an asynchronous loop on
            the thread pool, as long as the operation is pending.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation.Factory(System.Action)">
      <summary>
            Factory method to match the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory" /> signature.
            </summary>
      <param name="action">The action to be performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.</param>
      <returns>A new instance of <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />.</returns>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase">
      <summary>
            Base class for operations that cannot run while they is already in progress.
            </summary>
      <remarks>
        <para>
            This class handles the synchronization between the methods defined in the <see cref="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" />
            interface. Implementers should only need to implement the <see cref="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync" /> method to provide a
            mechanism for executing the action on a separate thread.
            </para>
        <para>
            If subclass implementations get constructed without an exception handler, applications should attach to the static
            <see cref="E:Gemstone.LibraryEvents.SuppressedException" /> event so that any unhandled exceptions can be exposed to a log.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action)">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action,System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.#ctor(System.Action{System.Threading.CancellationToken},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase" /> class.
            </summary>
      <param name="action">The cancellable action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
      <remarks>
            Cancellable synchronized operation is useful in cases where actions should be terminated
            during dispose and/or shutdown operations.
            </remarks>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.CancellationToken">
      <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken" /> to use for cancelling actions.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction">
      <summary>
            Executes the action once on the current thread.
            </summary>
      <returns>
        <c>true</c> if the action was pending and needs to run again; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteActionAsync">
      <summary>
             Executes the action on a separate thread.
             </summary>
      <remarks>
             Implementers should call <see cref="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ExecuteAction" /> on a separate thread and check the return value.
             If it returns true, that means it needs to run again. The following is a sample implementation using
             a regular dedicated thread:
             <code language="cs">
             protected override void ExecuteActionAsync()
             {
                 Thread actionThread = new Thread(() =&gt;
                 {
                     while (ExecuteAction())
                     {
                     }
                 });
            
                 actionThread.Start();
             }
             </code></remarks>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsPending">
      <summary>
            Gets flag indicating if the synchronized operation has an additional operation that is pending
            execution after the currently running action has completed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.IsRunning">
      <summary>
            Gets flag indicating if the synchronized operation is currently executing its action.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.ProcessException(System.Exception)">
      <summary>
            Processes an exception thrown by an operation.
            </summary>
      <param name="ex">
        <see cref="T:System.Exception" /> to be processed.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.Run(System.Boolean)">
      <summary>
            Executes the action on current thread or marks the operation as pending if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
        <para>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </para>
        <para>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </para>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.RunAsync">
      <summary>
            Executes the action on another thread or marks the operation as pending if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, operation will run again after currently running operation has
            completed. This is useful if an update has invalidated the operation that is currently running and will
            therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRun(System.Boolean)">
      <summary>
            Attempts to execute the action on current thread. Does nothing if the operation is already running.
            </summary>
      <param name="runPendingSynchronously">Defines synchronization mode for running any pending operation.</param>
      <remarks>
            When <paramref name="runPendingSynchronously" /> is <c>true</c>, this method will not guarantee that control
            will be returned to the thread that called it; if other threads continuously mark the operation as pending,
            this thread will continue to run the operation indefinitely on the calling thread.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationBase.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread. Does nothing if the operation is already running.
            </summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationFactory">
      <summary>
            Factory method for creating synchronized operations.
            </summary>
      <param name="action">The action to be synchronized by the operation.</param>
      <returns>The operation that synchronizes the given action.</returns>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType">
      <summary>
            Represents the available types of synchronized operations.
            </summary>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.Short">
      <summary>
        <see cref="T:Gemstone.Threading.SynchronizedOperations.ShortSynchronizedOperation" />
      </summary>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.Long">
      <summary>
        <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" />
      </summary>
    </member>
    <member name="F:Gemstone.Threading.SynchronizedOperations.SynchronizedOperationType.LongBackground">
      <summary>
        <see cref="T:Gemstone.Threading.SynchronizedOperations.LongSynchronizedOperation" /> with IsBackground set to <c>true</c></summary>
    </member>
    <member name="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation">
      <summary>
            Represents a task-based synchronized operation
            that cannot run while it is already in progress.
            </summary>
      <remarks>
        <para>
            The action performed by the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> is executed using
            <see cref="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />. Pending actions run when the task returned by the
            asynchronous action is completed. This synchronized operation only supports the async
            methods on the <see cref="T:Gemstone.Threading.SynchronizedOperations.ISynchronizedOperation" /> interface because the async action
            cannot be executed synchronously.
            </para>
        <para>
            The following example shows how to use <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> to
            implement a notifier that receives notification requests ad-hoc but sends notifications
            no more than once every 15 seconds.
            </para>
        <code>
            public ExampleClass() =&gt;
                SynchronizedOperation = new TaskSynchronizedOperation(NotifyAsync);
                
            public void SendNotification() =&gt;
                SynchronizedOperation.RunOnceAsync();
                
            private async Task NotifyAsync()
            {
                Notify();
                await Task.Delay(15000);
            }
            </code>
      </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.Tasks.Task})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.Tasks.Task},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{System.Exception})">
      <summary>
            Creates a new instance of the <see cref="T:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation" /> class.
            </summary>
      <param name="asyncAction">The action to be performed during this operation.</param>
      <param name="exceptionAction">The action to be performed if an exception is thrown from the action.</param>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.CancellationToken">
      <summary>
            Gets or sets <see cref="T:System.Threading.CancellationToken" /> to use for canceling actions.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.IsPending">
      <summary>
            Gets a value to indicate whether the synchronized operation
            has an additional operation that is pending execution after
            the currently running action has completed.
            </summary>
    </member>
    <member name="P:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.IsRunning">
      <summary>
            Gets a value to indicate whether the synchronized
            operation is currently executing its action.
            </summary>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.RunAsync">
      <summary>
            Executes the action on another thread or marks the
            operation as pending if the operation is already running.
            </summary>
      <remarks>
            When the operation is marked as pending, it will run again after the
            operation that is currently running has completed. This is useful if
            an update has invalidated the operation that is currently running and
            will therefore need to be run again.
            </remarks>
    </member>
    <member name="M:Gemstone.Threading.SynchronizedOperations.TaskSynchronizedOperation.TryRunAsync">
      <summary>
            Attempts to execute the action on another thread.
            Does nothing if the operation is already running.
            </summary>
    </member>
  </members>
</doc>